[{"title":"Mac根目录创建文件","url":"/2020/06/11/Mac%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6/","content":"方式1:\n\n重启mac\n按住command+r进入恢复模式\n点击用户登录\n在顶部导航栏选择Utilities-&gt;Terminal.app\n输入csrutil disable关闭SIP\n点击左上角苹果的logo重启\n重启完成后在Terminal中输入sudo mount -uw &#x2F;重新挂载根目录\n在根目录正常创建文件夹\n将其他目录的文件夹软连接到根目录文件夹ln -s &#x2F;Users&#x2F;xxxx&#x2F;test &#x2F;test&#x2F;\n设置777或者其他读写权限\n重启并按command+r进入恢复模式\n在恢复模式的Terminal输入csrutil enable重新开启SIP\n重启\n\n方式2:\n\n因为mac os引入了系统完整性保护(SIP)机制，无法在&#x2F;目录下新建文件，此处采用官方推荐做法来挂载。\n命令如下：\nsudo vim &#x2F;etc&#x2F;synthetic.conf\n之后进入编辑模式编辑此文件\n比如你要将家目录下www文件夹挂载到根目录，那么此文件内容应为：\nwww　　&#x2F;Users&#x2F;xxx&#x2F;www\n&#x2F;Users&#x2F;diruipu&#x2F;jerry2&#x2F;zrp&#x2F;ewell&#x2F;var&#x2F;log&#x2F;ewell\n这样重启Mac即可。\n注意：“www”与 “&#x2F;Users&#x2F;xxx&#x2F;www”中间的不是空格键，而是一个table的空格(也就是按一下table键就可以了)。否则不生效！\n\n","tags":["mac"]},{"title":"Oracle基础","url":"/2019/02/25/Oracle%E5%9F%BA%E7%A1%80/","content":"sql\nstructure  query  language    结构化语言   \nSQL 是用于访问和处理数据库的标准的计算机语言。\n\n查询简单查询语法结构：select  列名   from  表名\n关键词：from   确定数据来源\n    select  确定要获取哪些列\n\n查询部分列-- 需求：查询员工表中所有员工的工号、名字、工资-- 思路：--     确定数据来源  from employees--     确定获取哪些列  select employee_id、first_name、salary--     组合select employee_id,first_name,salaryfrom employees\n\n查询全部列-- 需求：查询所有员工的所有信息-- 思路：--     确定数据来源  from employees--     确定获取哪些列  select employee_id,first_name,last_name,email,phone_number,hire_date,job_id,salary,commssion_pct,manager_id,department_id-- 方法一：select employee_id,first_name,last_name,email,phone_number,hire_date,job_id,salary,commssion_pct,manager_id,department_idfrom employees-- 方法二：select *from employees\n\n\n两种方法的优劣：从实际开发角度：推荐第一种， 获取所有列的次数是很少见；第二种慢，效率低,可读性差\n\n查询结果起别名语法结构：select   列名1 as  别名1,列名2 as 别名2，列名3  别名3 from  表名 \n\nas 可以省略\n\n-- 需求：查询员工表中所有员工的工号、名字、工资，展示效果为工号、名字、工资select employee_id as 工号,frist_name 名字,salary 工资from employees\n\n字符串拼接语法结构：select  列名1||列名2,列名3 from employees\n-- 需求：查询员工表，工号，姓名（first_name||last_name），工资-- 版本1.0select employee_id,first_name||last_name,salaryfrom employees-- 版本2.0--起别名select employee_id,first_name||last_name 姓名,salaryfrom employees-- 版本3.0--连续拼接select employee_id,first_name||&#x27;·&#x27;||last_name 姓名,salaryfrom employees\n\n查询结果做算数运算-- 需求：查询员工的工号、名字、年薪（salary*13）select employee_id,first_name,salary*13 年薪from employees\n\n\n去重概念：如果查询结果中有多行数据完全一致，过滤掉重复，只保留一行\n语法结构：select distinct 列名，列名  from 表名\n关键词：distinct  重复数据\n-- 需求：查询员工表中所有的领导-- 查询manager_id列的所有数据select manager_idfrom employees-- 去重版：select distinct manager_idfrom employees\n\n排序语法结构：select  列名  from 表名 order by  列名 asc(升序)|desc(降序),列名 asc|desc\n关键词：order by  \n    asc升序   desc 降序\n\n注意：若没有表明desc或asc  默认升序 asc\n-- 需求：查询员工表，工号、名字、工资，并且对工资做降序排序-- 确定数据来源   from employees--        确定获取哪些列的数据  select employee_id,first_name,salary--        排序  order by salary desc--        组合select employee_id,first_name,salary from employeesorder by salary desc-- 需求：查询员工的工号，姓名，工资，对工资最降序排序，若工资相同，根据工号做升序 -- 确定数据来源 from employees--    确定获取哪些列的数据 select employee_id,first_name,salary--    排序     order by salary desc,employee_id desc--    组合select employee_id,first_name,salaryfrom employeesorder by salary desc,employee_id desc\n\n\n\n子查询概念：一个查询语句，需要用到另一个查询语句的结果\n-- 需求：查询员工表中，工资最高的人的信息-- 思路：-- 第一步：找出最大值-- select max(salary) from employees------maxSalary-- 第二步：找出具有maxSalary的员工-- select * from employees where salary = maxSalary-- 第三步：组合select *from employees where salary = (select max(salary) from employees)\n\n子查询结果为一行一列\n这种子查询结果，一般作为主查询的条件判断 ，等值判断，或不等值判断\n\n-- 需求：查询员工表中大于平均薪资的员工信息-- 第一步：求出平均薪资-- select avg(salary) from employees----avgSalary-- 第二步：筛选出所有大于平均薪资的员工-- select first_name,salary from employees where salary &gt;avgSalary-- 第三步：组合select first_name,salaryfrom employeeswhere salary &gt;(select avg(salary) from employees)\n\n子查询结果为n行一列\n这种子查询结果，一般作为主查询的条件判断，枚举\n\n-- 需求：查询员工表中所有和姓为&#x27;King&#x27;的员工在一个部门的员工信息-- 第一步：查出‘King’ 所在部门-- select  department_id from employees where last_name = &#x27;King&#x27;-- 第二步：查询这些部门中的员工-- select from employees where department_id in (值1，值2)-- 第三步：组合select first_name,last_name,department_idfrom employeeswhere department_id in (select  department_id from employees where last_name = &#x27;King&#x27;)\n\n子查询结果为n行n列\n这种子查询结果，一般作为一个临时表，让主查询使用\n\n-- 需求：查询工资最高的前10名员工-- 思路：-- 第一步：排序-- select * from employees order by salary desc-- 第二步+第三步：取前十+组合select * from (select * from employees order by salary desc) where rownum &lt;=10\n\n\n\n分页查询-- 需求：查询第11名到第20名员工信息-- 思路：-- 第一步：将rownum变成一个真实的字段-- select rownum rn ,e.* from employees e-- 第二步+第三步：基于上表，做区间查询+组合select *from (select rownum rn ,e.* from employees e)where rn between 11 and 20;-- 需求：对员工表根据工资做降序排序，获取第38名到第68名员工信息[笔试必考]-- 思路：-- 第一步：先降序排序-- select * from employees order by salary desc;---empl-- 第二步：将rownum变成一个真实的字段-- select rownum rn,e.*-- from emp1 e----emp2-- 第三步：获取第38-68名-- select *-- from emp2-- where rn between 38 and 68-- 第四步：组合select *from (    select rownum rn,e.* from (        select * from employees order by salary desc    ) e)where rn between 38 and 68;\n\n\n\n条件查询概念：对每一条数据进行条件判断，满足条件放入查询结果\n关键词：where  条件\n语法结构：select  列名  from   表名  where   条件\n等值查询-- 需求：查询员工表中工资等于17000的员工信息，工号，名字，工资-- 确定数据来源 from employees--     条件判断    where salary = 17000--     确定获取哪些列 select employee_id,first_name,salary--     组合select employee_id,first_name,salaryfrom employeeswhere salary = 17000;\n\n不等值查询  &gt;  &lt;  &gt;&#x3D;  &lt;&#x3D; !&#x3D;-- 需求：查询员工表中所有工资大于17000的员工信息-- 确定数据来源 from employees--     条件判断    where salary &gt; 17000--     确定获取哪些列 select employee_id,first_name,salary--     组合select employee_id,first_name,salaryfrom employeeswhere salary &gt;17000;\n\n多条件查询关键词：or 或  and且  \n语法结构  where   条件1 or|and 条件2\n-- 需求：查询员工表中工资大于10000，并且小于24000的员工信息-- 确定数据来源 from employees--     条件判断    where salary &gt; 10000 and salary&lt;24000--     确定获取哪些列 select employee_id,first_name,salary--     组合select employee_id,first_name,salaryfrom employeeswhere salary&gt;10000 and salary&lt;24000-- 需求：查询员工表中90号部门或者100号部门的员工信息-- 确定数据来源 from employees    -- 条件判断    where department_id = 90 or department_id=100--     确定获取哪些列 select employee_id,first_name,salary    -- 组合select employee_id ,first_name,salaryfrom employeeswhere department_id = 90 or department_id = 100\n\n区间查询关键词：条件字段  between  起始值  and  结束值  \n特点：闭区间查询  字段&gt;&#x3D;起始值 and 字段&lt;&#x3D; 结束值\n语法结构：where 条件字段  between 起始值 and  结束值\n-- 需求：查询员工表中工资大于等于10000，并且小于等于24000的员工信息-- 多条件：select *from employeeswhere salary &gt;=10000 and salary&lt;=240000-- 区间查询：select employee_id ,first_name ,salaryfrom employeeswhere salary between 10000 and 24000;\n\n枚举查询关键词 ： in（值1，值2，值3）\n语法结构：where 条件字段 in (值1，值2)\n-- 需求：查询员工表中90号部门或者100号部门的员工信息select employee_id ,first_name,salary,department_idfrom employeeswhere department_id in (90,100);\n\n模糊查询\n关键词：like  ‘模糊匹配语法字符串’\n\n模糊匹配：\n_:代表任意一个字符\n%：代表任意0~n个字符\n字符串类型用单引号表示\n\n-- 需求：查询员工表中名字一‘K’开头的员工信息select employee_id,first_namefrom employeeswhere first_name like &#x27;k%&#x27;-- 需求：查询员工表中名字长度为4的员工信息select first_namefrom employeeswhere first_name like &#x27;____&#x27;\n\n空值（null）查询关键词：is [not] null\n语法结构：where 条件字段  is  [not]  null\n-- 需求：查询出员工表中所有没有提成（commission_pct）的员工select employee_id,first_name,salary,commission_pctfrom employeeswhere commission_pct is null-- 需求：查询出员工表中所有有提成（commission_pct）的员工select employee_id,first_name,salary,commission_pctfrom employeeswhere commission_pct is not null\n\n分支查询    case  when位置：经常写在select后面\n作用：对查询结果进行进一步的处理，以一种符合用户习惯的方式展现\n--需求：查询员工表，将工资分为高薪，中等，低薪select first_name,salary,case    when salary&gt;=17000  then &#x27;高薪&#x27;    when salary&gt;=10000  then &#x27;中等&#x27;    else &#x27;低薪&#x27;end as 工资级别from employees\n\n特殊关键词\nsysdate  系统时间   年  月 日 时 分 秒 \nsystimestamp [时间戳]   系统时间  年 月 日 时 分 秒    毫秒\n&gt;--需求：获取当前系统时间&gt;select sysdate&gt;from employees&gt;select systimestamp&gt;from employees\n\ndual   虚表  只有一行一列的表，常用于测试\n从数据的角度上：没有任何意义\n作用：维护Oracle数据库sql语法的完整性\n&gt;--需求：获取当前系统时间&gt;select sysdate&gt;from dual\n\n\n\n函数概念：具备特定功能的sql命令\n\n函数三要素：返回值类型、函数名、参数列表\n\n函数分类：单行函数、组函数\n单行函数特点：每处理一行数据，都会有一个返回结果\n107行  —–单行函数—-》107个结果\nlength(‘字符串’)\n计算字符串的长度\n\n-- 需求：计算&#x27;abcdefgdfdf&#x27;的长度select length(&#x27;abcdefgdfdf&#x27;)from dual-- 需求：查询员工表中名字长度为4的员工信息select employee_id,first_namefrom employeeswhere length(first_name)=4\n\nto_date(‘字符串类型的日期’,’日期转换格式’)\n把字符串类型的日期，转换为日期类型\n\n-- 需求：将’2020-10-23‘转换成日期格式select to_date(&#x27;2020-10-23&#x27;,&#x27;yyyy-mm-dd&#x27;)from dual\n\nto_char(日期类型的日期，’日期转换格式’)\n将日期类型转换成字符串类型\n\n-- 需求：将当前系统时间转换成字符串select to_char(sysdate,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;)from dual;-- 需求：求出在坐的各位的同学出生年月日是星期几select to_char(to_date(&#x27;1999-02-28&#x27;,&#x27;yyyy-mm-dd&#x27;),&#x27;day&#x27;)from dual\n\nmod（被除数,除数)\n求余数\n\n--需求：求余数select mod(10,3)from dual\n\nnvl(x1,x2)\n如果x1是null，就是返回x2,不是null,返回本身\n\n-- 需求select nvl(null,&#x27;hahahhh&#x27;)from dual-- 需求：查询员工表中所有员工的提成，若没有提成，则显示0select nvl(commission_pct,0)from employees\n\n\n小总结\n关键词：\n&gt;from     确定数据来源的表&gt;where    筛选出满足条件的数据&gt;select   确定获取哪些列数据&gt;order by 根据某一字段对查询结果进行排序 &gt;distinct 过滤重复数据\n\n语法结果：select  …  from  …  where … order by\n执行顺序：from   where   select  order by\n\n组函数特点：每一组只有一个返回结果\n作用：对已经确定的表或组进行数据统计、分析\n\nwhere后面不能使用组函数\n\n组函数不对null进行任何统计处理\n\n若使用组函数，select 后面只能写组函数\n\n\n常用的组函数\ncount(字段)    统计有效行数\n\nmax(字段)\t\t最大值\n\nmin(字段)  \t最小值\n\navg(字段)\t\t平均值\n\nsum(字段)   \t 求和\n\n\n-- 需求：统计员工表中有提成员工的个数--     确定数据来源  from  employees--     筛选数据     where commission_pct  is not null--     确定获取哪些列 select count(commission_pct)select count(commission_pct)from employees--where commission_pct is not null-- 需求：查询员工表中工资最高、最低的员工select max(salary) ,min(salary),avg(salary)from employees\n\n分组关键词：group by  字段    根据字段进行分组\n语法结构：select … from …  where … group by …  order by\n补充：分组之后，select后面能写组函数以及分组依据字段\n-- 需求：统计员工表中每个部门的人数--    分组   group by  department_id--     统计   select count(employee_id),department_idselect count(employee_id),department_idfrom employeesgroup by department_id-- 需求：统计员工表中每个部门的平均薪资select avg(salary),department_idfrom employeesgroup by department_id-- 需求：查询每个工种的人数以及工种idselect count(employee_id),job_idfrom employeesgroup by job_id\n\n分组过滤关键词：having    对分组之后的数据进行筛选，过滤\n语法结构：select … from … where … group by … having … order by\n-- 需求：查询部门平均薪资大于9000的部门id以及平均薪资-- 分组 group by department_id--    分组过滤 having avg(salary)&gt;9000--    获取数据 select department_id,avg(salary)--    组合select department_id,avg(salary)from employeesgroup by department_idhaving avg(salary)&gt;9000-- 需求：查询70,80,90部门的平均薪资-- 第一种思路：--     筛选数据   where department_id in(70,80,90)--     分组      group by department_id--     获取       select avg(salary),department_id    select avg(salary),department_idfrom employeeswhere department_id in (70,80,90)group by department_id-- 第二种思路：--     分组： group by deparment_id--     分组过滤： having department_id in(70,80,90)--     获取 ：   select avg(salary) ,department_idselect avg(salary),department_idfrom employeesgroup by department_idhaving department_id in (70,80,90)\n\n\nwhere是在分组前过滤数据having是在分组后过滤数据当两种方法都能解决问题，优先使用where\n\n伪列概念：建表时，不存在的列，但是，查询时，可以查到\n分类：rowid和rownum\nrowid概念：一行数据存在硬盘的物理地址，可以唯一标示一行数据\n\n物理地址：一行数据在硬盘上的具体位置\n\n-- 需求：查询员工表中员工信息，工号，名字，salary，物理地址（rowid）select employee_id,first_name,salary,rowidfrom employees\n\nrownum概念：对查询结果做一个编号（从1开始，依次递增）\n\n特点：\n\n从1开始，依次递增\n对满足where条件的数据进行编号\nrownum做比较时，&lt;  &lt;&#x3D;  &gt;&#x3D;1  &#x3D;1\n\n\n-- 需求：查询所有员工信息，做rownumselect e.*,rownumfrom employees e-- 需求：查询前10名员工select employee_id,first_name,salary,rownumfrom employeeswhere rownum&lt;=10-- 需求：查询工资最高的前10名员工-- 思路：--     排序 order by salary desc--     筛选 where rownum&lt;=10    select first_name,salary,rownumfrom employeeswhere rownum &lt;=10;order by salary desc 错误   where比order by先执行-- 需求：查询第11名到第20名员工信息select first_name,salary,rownumfrom employeeswhere rownum between 11 and 20  错误\n\n表连接\n根据连接条件，将多张表连接成一张表，放在from后面使用\n\n内连接关键词：[inner] join\n语法：表1 [inner] join  表2  on  表1.字段n  &#x3D; 表2.字段n\n-- 需求：查询员工信息，工号，名字，工资，部门编号，部门名称-- 思路：-- 第一步：确定连接那两张表-- employees e join departments d -- 第二步：确定连接条件-- on e.department_id = d.department_id-- 第三步：组合select e.employee_id,e.first_name,e.salary,e.department_id,d.department_namefrom employees e join departments d on e.department_id = d.department_id\n\n特点：\n\n将左表与右表中互相对应的数据连接到一张表里\n若左表存在，右表中没有与之对应的数据，直接舍弃\n\n外链接左外链接关键词：left [outer] join \n语法：表1 left join 表2 on 连接条件\n-- 需求：查询员工信息，工号，名字，工资，部门编号，部门名称select e.employee_id,e.first_name,e.salary,d.department_id,d.department_namefrom employees e left join departments d on e.department_id = d.department_id\n\n特点：若左表存在，右表中没有与之对应的数据，保留，右表缺失的数据补空\n右外链接关键词：right [outer] join \n特点：若右表存在，左表中没有与之对应的数据，保留，左表缺失的数据补空\n完整外链接关键词：full [outer] join\n特点：无论是否有对应数据，统统保留 \n表连接应用-- 需求：查询部门信息：部门编号，部门名称，部门所在地标号，部门所在城市select d.department_id ,d.department_name,l.location_id,l.cityfrom departments d left join locations l on d.location_id = l.location_id-- 需求：查询员工的工号，名字，工资，部门编号，部门名称，部门所在地编号，部门所在城市select e.employee_id,e.first_name,e.salary,d.department_id,d.department_name,l.location_id,l.cityfrom employees e left join departments d on e.department_id = d.department_idleft join locations l on d.location_id = l.location_id-- 需求：查询员工的工号，名字，工资，领导编号，领导名字-- 自连接：自己连接自己，物理上是一张表，逻辑上是两张表-- 说明：并不是新的连接方式，只是一个特殊的连接技巧select e1.employee_id,e1.first_name,e1.salary,e1.manager_id,e2.first_namefrom employees e1 left join employees e2 on e1.manager_id = e2.employee_id\n\n建表\n一张表里面包含哪些东西？表名       必须字段名      必须数据类型   必须约束   进一步限制了字段中值的内容   不必须   根据需求\n建表语法：create table 表名(字段名  数据类型  [约束]，字段名  数据类型  [约束]，…..字段名  数据类型  [约束])\n\n修改表结构：\nalter table 表名 add 字段名  数据类型 [约束]-----给已经存在的表增加新的字段\nalter table 表名 drop column 字段名-----删除表中已经存在的字段\n\n删表：drop table 表名\n\n数据类型数字类型number(n)  整数  最大长度为n  \n  number(n,m)  小数  n是总长度，m是小数部分长度  整数部分长度为n-m\n                      如果小数部分长度没有达到m，后面补0,支持四舍五入\n\n  integer ，double—已过时，不建议使用\n字符串类型  char(n)   定长字符串   数据长度不够n,以空白字符填充  ‘abc  ‘\n  varchar2(n) 可变长字符串     数据长度不够n,那就算了，不填充空白字符\n日期类型  date   包含年月日时分秒\n大文本类型  clob   varchar2最大能存4000个字符  \n约束主键约束(primary key)唯一标示一行数据   唯一+非空\n应用场景：工号，学号，编号...\n\n唯一约束(unique)值唯一，不能重复\n\n应用场景：手机号，身份证号，邮箱....\n\n非空约束语法：not null  值不能为空\n应用场景：名字，年龄....\n\n检查约束语法：check（约束语法）\n应用场景：\n    银行卡密码：check(length(字段名)=6)\n    邮箱：check（字段名 like &#39;%@qq.com&#39;）\n\n外键约束（foreign key）语法：references 表名(主键字段名)\n关键词：references  指向，引用\n作用：从数据角度上给两张表建立一个连接关系\n特点：子表中加了外键约束的字段中的值，必须从指向主表中的主键列中获取，或者 为null\n例子：学生表(t_stu)中有class_id references t_class(class_id),班级表(t_class)中也有class_id primary key\n\n\n存在外键约束的表称之为子表，外键指向的表称之为主表注意：\n先建主表，后建子表\n先删子表，后删主表\n先往主表中添加数据，在往子表中添加数据\n\n\n-- 需求：创建学生表（t_stu）和班级表（t_class）.学生表中有字段如下学号stu_id,名字stu_name，性别stu_sex,年龄stu_age，班号class_id;班级表中有如下字段：班号class_id,班级名称class_namecreate table t_class(    class_id number(4) primary key,    class_name varchar2(20) not null);create table t_stu(    stu_id number(3) primary key,    stu_name varchar2(10) not null,    stu_sex varchar2(4) check(stu_sex in(&#x27;男&#x27;,&#x27;女&#x27;,&#x27;其他&#x27;))，    stu_age number(3) check(stu_age between 16 and 50),    class_id references t_class(class_id))\n\n增删改操作添加数据（增）语法： insert into 表名 (字段名1，字段名2，字段名3…) values (值1，值2，值3，….)关键词： insert into…. values\n\nvalues后的值的顺序要和表名后字段名的顺序保持一致\n表名后的字段可以省略，此时Oracle默认全部字段添加，并且按照建表时的字段顺序，添加值\n\n-- 需求：向班级表中添加一行数据insert into t_class (class_id,class_name) values (1908,&#x27;百知java1908&#x27;)-- 需求:向学生表中添加两行数据insert into t_stu (stu_id,stu_name,stu_age,stu_sex,class_id) values (1,&#x27;杨雨龙&#x27;,38,&#x27;其他&#x27;,1908) insert into t_stu values (2,&#x27;司马超凡&#x27;,&#x27;女&#x27;,18,1908)\n\n删除操作（删）语法： delete [from] 表名 [where条件] \n特点：逐行删除满足条件数据\n\n注意：若不加where条件，会将全表的数据都给删掉，表还存在\n\n-- 需求:删除学生表中的学号为1的学生信息delete from t_stu where stu_id = 1\n\n\n补充：表截断：实际上也是删除表中的数据语法： truncate table 表名特点：是直接从表的实际存储位置上，将表的数据部分截断并丢弃优点:效率快\n\n修改操作（改）语法：update 表名 set 字段1 &#x3D; 新值1，字段2 &#x3D; 新值2[where 条件]\n\n注意：若不添加where条件，会将全表的相应字段都做修改\n\n-- 需求：将学生表中学号为3的学生名字改为‘程某’update t_stu set stu_name = &#x27;程某&#x27; where stu_id = 3\n\nsql分类ddl:数据定义语言  create  alter  drop\ndml:数据操作语言  insert  delete  update\ndql:数据查询语言  select\ntcl:事务控制语言   commit  rollback\n事务\n问题：银行存钱，取钱，转账业务怎么实现\n银行用户表：bank_account\n\n\n\nid\nname\ncardid\npassword\nbalance\n\n\n\n1\n黄亮\n1001\n123456\n10000\n\n\n2\n大漂亮\n1002\n654321\n5000\n\n\n&gt;-- 转账：黄亮为了避免一个人过‘光棍节’，需要给他女朋友大漂亮资助9998过劫费&gt;-- 第一步：先将黄亮账户余额减去9998&gt;update bank_account set balance = 2 where cardid = 1001and password = 123456&gt;-- 第二步：再将大漂亮账户余额加上9998&gt;update bank_account set balance = 14998 where cardid = 1002 and password = 654321&gt;-- 可能发生意外情况：导致第一步执行成功，但是第二步执行失败&gt;-- 希望情况：要么两步都执行成功，要么都执行失败&gt;-- 总结：将实现一个功能的所有sql语句当成一个整体，要么全部执行成功，要么全部执行失败--事务\n\n概念：数据库中的dml语句的最小执行单元，将多个sql当做一个整体\n特点：要么全部执行成功，要么全部执行失败\n事务的使用：\n1.成功结束事务：commit(提交)\n2.失败结束事务：rollback(回滚)\n\n事务的实现简单步骤\n数据库会为每一个客户端都分配一个回滚段（临时空间 rollback seagment）,回滚段中存储着当前客户端的数据处理结果\n\ncommit（提交），将回滚段中的结果同步到数据库当中\n\nrollback(回滚)，将回滚段中的结果丢弃\n\n\n事务的边界事务的开启时机：\n上一个事务结束\n执行dml语句\n\n事务的结束时机提交：\n\n\ncommit\n\n正常退出客户端\n\n执行ddl语句的时候\n  回滚：\n\nrollback\n\n非正常退出\n\n\n\neg：\n&gt;--问题：以下操作，有几个事务&gt;insert&gt;insert&gt;commit&gt;select&gt;rollback&gt;update&gt;delete&gt;commit&gt;delete&gt;rollback&gt;--总共三个事务，两次提交，一次回滚\n\n\n事务的特性ACID\n原子性：一个中的多个sql语句，要么全部执行成功，要么全部执行失败\n\n一致性：一个事务的结束（成功或失败），数据的修改是一致的，合理的\n\n隔离性：一个客户端的事务结束前，其他客户端事务不可见\n\n持久性：事务的结束（无论成功或失败），对于数据的影响是永久的\n\n\n序列概念：Oracle自带的一个工具，可以自动生成一系列连续不重复的值\n应用：添加数据时，作为主键的值\n创建序列：create sequence 序列名 [start with 值]\n使用序列：\n\n序列名.nextval   获取到序列中下一个值\n序列名.currval   获取序列当前的值\n\n-- 应用：创建序列，获取序列中的值create sequence stu_seq start with 4select stu_seq.nextval from dual---值为4select stu_seq.currval from dual---值为4select stu_seq.nextval from dual---值为5select stu_seq.currval from dual---值为5-- 应用：通过序列往表中添加数据insert into t_stu values(stu_seq.nextval,&#x27;小司马&#x27;,&#x27;男&#x27;,23,1908)\n\n删除序列：drop sequence 序列名\n视图语法：create view 视图名 as select语句\n概念：将一个select语句的查询结果，当做一个视图（一个虚拟的表），供后来查询使用\n-- 视图的使用create view stu_view as select * from t_stuselect * from stu_view\n\n优点：\n\n简化sql语句\n对部分开发人员屏蔽掉表名及字段名关键信息\n\n注意：\n\n视图能够提高查询效率——错误\n\n删除视图：drop view 视图名\n索引\n问题：当Oracle数据库中的数据量达到1000万，查询效率就会直线下降\n当查询数据时，会对全表中的所有数据都进行筛选，找出符合要求的数据。如果我们能够对数据库创建出一个类型图书目录的结构，这个结构就是索引\n\n概念：类似图书目录的结构，提高查询效率\n创建索引：create index 索引名 on 表名(字段名)\n相当于：create index 目录名  on 西游记（章节名）\n删除索引：drop index 索引名\n使用索引：不需要手动使用，当以索引字段进行查询时，会自动使用索引，提高查询效率\n索引的特点：\n\n索引会占用硬盘空间\n索引会降低dml操作的效率\n只有以创建索引的字段为查询条件时，才会提高查询效率\n主键约束和唯一约束的字段，会被默认添加索引\n\n","tags":["oracle","sql"]},{"title":"Oracle练习","url":"/2019/02/26/Oracle%E7%BB%83%E4%B9%A0/","content":"建表语句\ncreate table student(    sno varchar2(10) primary key,    sname varchar2(20),    sage number(2),    ssex varchar2(5));create table teacher(    tno varchar2(10) primary key,    tname varchar2(20));create table course(    cno varchar2(10),    cname varchar2(20),    tno varchar2(20),    constraint pk_course primary key (cno,tno));create table sc(    sno varchar2(10),    cno varchar2(10),    score number(4,2),    constraint pk_sc primary key (sno,cno));/*******初始化学生表的数据******/insert into student values (&#x27;s001&#x27;,&#x27;张三&#x27;,23,&#x27;男&#x27;);insert into student values (&#x27;s002&#x27;,&#x27;李四&#x27;,23,&#x27;男&#x27;);insert into student values (&#x27;s003&#x27;,&#x27;吴鹏&#x27;,25,&#x27;男&#x27;);insert into student values (&#x27;s004&#x27;,&#x27;琴沁&#x27;,20,&#x27;女&#x27;);insert into student values (&#x27;s005&#x27;,&#x27;王丽&#x27;,20,&#x27;女&#x27;);insert into student values (&#x27;s006&#x27;,&#x27;李波&#x27;,21,&#x27;男&#x27;);insert into student values (&#x27;s007&#x27;,&#x27;刘玉&#x27;,21,&#x27;男&#x27;);insert into student values (&#x27;s008&#x27;,&#x27;萧蓉&#x27;,21,&#x27;女&#x27;);insert into student values (&#x27;s009&#x27;,&#x27;陈萧晓&#x27;,23,&#x27;女&#x27;);insert into student values (&#x27;s010&#x27;,&#x27;陈美&#x27;,22,&#x27;女&#x27;);commit;/******************初始化教师表***********************/insert into teacher values (&#x27;t001&#x27;, &#x27;刘阳&#x27;);insert into teacher values (&#x27;t002&#x27;, &#x27;谌燕&#x27;);insert into teacher values (&#x27;t003&#x27;, &#x27;胡明星&#x27;);commit;/***************初始化课程表****************************/insert into course values (&#x27;c001&#x27;,&#x27;J2SE&#x27;,&#x27;t002&#x27;);insert into course values (&#x27;c002&#x27;,&#x27;Java Web&#x27;,&#x27;t002&#x27;);insert into course values (&#x27;c003&#x27;,&#x27;SSH&#x27;,&#x27;t001&#x27;);insert into course values (&#x27;c004&#x27;,&#x27;Oracle&#x27;,&#x27;t001&#x27;);insert into course values (&#x27;c005&#x27;,&#x27;SQL SERVER 2005&#x27;,&#x27;t003&#x27;);insert into course values (&#x27;c006&#x27;,&#x27;C#&#x27;,&#x27;t003&#x27;);insert into course values (&#x27;c007&#x27;,&#x27;JavaScript&#x27;,&#x27;t002&#x27;);insert into course values (&#x27;c008&#x27;,&#x27;DIV+CSS&#x27;,&#x27;t001&#x27;);insert into course values (&#x27;c009&#x27;,&#x27;PHP&#x27;,&#x27;t003&#x27;);insert into course values (&#x27;c010&#x27;,&#x27;EJB3.0&#x27;,&#x27;t002&#x27;);commit;/***************初始化成绩表***********************/insert into sc values (&#x27;s001&#x27;,&#x27;c001&#x27;,78.9);insert into sc values (&#x27;s002&#x27;,&#x27;c001&#x27;,80.9);insert into sc values (&#x27;s003&#x27;,&#x27;c001&#x27;,81.9);insert into sc values (&#x27;s004&#x27;,&#x27;c001&#x27;,60.9);insert into sc values (&#x27;s001&#x27;,&#x27;c002&#x27;,82.9);insert into sc values (&#x27;s002&#x27;,&#x27;c002&#x27;,72.9);insert into sc values (&#x27;s003&#x27;,&#x27;c002&#x27;,81.9);insert into sc values (&#x27;s001&#x27;,&#x27;c003&#x27;,&#x27;59&#x27;);commit;\n\n\n查询“c001”课程比“c002”课程成绩高的所有学生的成绩信息:\nselect a.* from    (select * from sc a where a.cno = &#x27;c001&#x27;) a,    (select * from sc b where b.cno = &#x27;c002&#x27;) bwhere a.sno=b.sno and a.score &gt; b.score;-- orselect * from sc awhere a.cno = &#x27;c001&#x27;and  exists (select * from sc b where b.cno=&#x27;c002&#x27; and a.score &gt; b.score and a.sno = b.sno);\n\n\n查询平均成绩大于60分的同学的学号和平均成绩\nselect sno,avg(score) from sc group by sno having avg(score) &gt; 60;\n\n\n查询所有同学的学号、姓名、选课数、总成绩\nSELECT a.sno, a.sNAME,sum(score),count(b.cno)FROM student a, sc bWHERE a.sno = b.sno(+)group by a.sno,sname;\n\n\n查询姓“刘”的老师的个数：\nselect count(1) from TEACHER where TNAME LIKE &#x27;刘%&#x27;;\n\n","tags":["oracle","sql"]},{"title":"RabbitMQ安装过程","url":"/2020/04/27/RabbitMQ%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/","content":"Linux 下单机版# 在安装任何软件包之前，建议您使用以下命令更新软件包和存储库。yum -y update# RabbitMQ是用Erlang语言编写的，在本教程中我们将安装最新版本的Erlang到服务器中。# Erlang在默认的YUM存储库中不可用，因此您将需要安装EPEL存储库。 yum -y install epel-release# 现在使用以下命令安装Erlang。yum -y install erlang socat# 您现在可以使用以下命令检查Erlang版本。erl -version# 下载RabbitMQwget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.10/rabbitmq-server-3.6.10-1.el7.noarch.rpm# 运行RPM安装RPM包：rpm -Uvh rabbitmq-server-3.6.10-1.el7.noarch.rpm# 启动systemctl start rabbitmq-server# 启动systemctl start rabbitmq-server# 要在引导时自动启动RabbitMQ，请运行以下命令。systemctl enable rabbitmq-server# 查看状态systemctl status rabbitmq-server# 停止systemctl stop rabbitmq-server\nMac 下单机版brew updatebrew install rabbitmq# 在~/.bash_profile 新加 环境变量# 如果被锁住删了原来的配置 touch .bash_profile touch .bash_profile# RabbitMQ Configexport PATH=$PATH:/usr/local/sbinsource ~/.bash_profile启动停止rabbitmqctl stoprabbitmq-serverbrew services stop rabbitmq\n","tags":["mac","RabbitMQ","linux"]},{"title":"Vue笔记","url":"/2020/04/13/Vue%E7%AC%94%E8%AE%B0/","content":"简介\nVue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\nHelloWorld\n数据绑定最常见的形式就是使用 &#123;&#123;值&#125;&#125;（双大括号）的文本插值：\n\n&lt;body&gt;    &lt;!--&#123;&#123;&#125;&#125;插值表达式，可以将vm对象的数据插入到视图中 --&gt;    &lt;div id=&quot;app&quot;&gt;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt;    &lt;script&gt;        const vm = new Vue(&#123;            el:&quot;#app&quot;,//通过选择器，选则要挂载的标签            data:&#123;//数据                msg:&quot;hello &quot;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt; \n\n\n内置指令v-bind单向数据绑定 简写 :xxx\n示例:\n&lt;div :class=&quot;color&quot;&gt;&lt;/div&gt;完整示例&lt;head&gt;    &lt;style type=&quot;text/css&quot;&gt;        .red_bg&#123;            background-color: red;        &#125;        .green_bg&#123;            background-color: green;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;         &lt;div id=&quot;app&quot;&gt;         &lt;div class=&quot;&#123;&#123;class_name&#125;&#125;&quot;&gt;点击按钮改变背景样式:&#123;&#123;class_name&#125;&#125;&lt;/div&gt;         &lt;div v-bind:class=&quot;class_name&quot;&gt;点击按钮改变背景样式:&#123;&#123;class_name&#125;&#125;&lt;/div&gt;         &lt;div :class=&quot;class_name&quot;&gt;点击按钮改变背景样式:&#123;&#123;class_name&#125;&#125;&lt;/div&gt;         &lt;button @click=&quot;class_name=&#x27;red_bg&#x27;&quot;&gt;红色&lt;/button&gt;         &lt;button @click=&quot;class_name=&#x27;green_bg&#x27;&quot;&gt;绿色&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        const vm = new Vue(&#123;            el:&quot;#app&quot;,            data:&#123;                class_name:&quot;&quot;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;\n\nv-model双向数据绑定\n&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt; &lt;br&gt;    &lt;button @click=&quot;setName&quot;&gt;点我设置value&lt;/button&gt;    &lt;button @click=&quot;getName&quot;&gt;点我获取value&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            name:&quot;&quot;        &#125;,        methods:&#123;            setName()&#123;                this.name=&quot;xiaohei&quot;;            &#125;,            getName()&#123;                alert(this.name);            &#125;        &#125;    &#125;)&lt;/script&gt;\n\nv-forVue中通过v-for指令来遍历\n遍历数组语法：\nv-for=&quot;(item,index) in items&quot;\n\n\nitems：要遍历的数组，需要在vue的data中定义好。\nitem：数组元素\nindex：元素下标，可以省略\n\n示例：\n&lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;        &lt;li v-for=&quot;(item,index) in favorites&quot;&gt;&#123;&#123;index+ &quot;:&quot;+item&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            favorites:[&#x27;唱&#x27;,&#x27;跳&#x27;,&#x27;Rap&#x27;,&#x27;打篮球&#x27;]        &#125;    &#125;);&lt;/script&gt;\n\n再看一个对象数组的示例：\n&lt;div id=&quot;app&quot;&gt;    &lt;table&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;name&lt;/th&gt;                &lt;th&gt;age&lt;/th&gt;                &lt;th&gt;gender&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr v-for=&quot;u in users&quot;&gt;                &lt;td&gt;&#123;&#123;u.name&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;u.age&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;u.gender&#125;&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;    &lt;button onclick=&quot;addPerson()&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            users: [                &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 13, &quot;gender&quot;: &quot;男&quot;&#125;,                &#123;&quot;name&quot;: &quot;小红&quot;, &quot;age&quot;: 13, &quot;gender&quot;: &quot;女&quot;&#125;,                &#123;&quot;name&quot;: &quot;小绿&quot;, &quot;age&quot;: 4, &quot;gender&quot;: &quot;男&quot;&#125;            ]        &#125;    &#125;);        function addPerson()&#123;        vm.users.push(&#123;&quot;name&quot;: &quot;小翠&quot;, &quot;age&quot;: 14, &quot;gender&quot;: &quot;女&quot;&#125;)    &#125;&lt;/script&gt;\n\n遍历对象v-for除了可以迭代数组，也可以迭代对象。语法基本类似\n语法：\nv-for=&quot;value in object&quot;v-for=&quot;(value,name) in object&quot;v-for=&quot;(value,name,index) in object&quot;\n\n\n1个参数时，得到的是对象的属性值\n2个参数时，第一个是属性值，第二个是属性名\n3个参数时，第三个是索引，从0开始\n\n示例：\n&lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;        &lt;li v-for=&quot;(value,name,index) in person&quot;&gt;&#123;&#123;index&#125;&#125; - &#123;&#123;name&#125;&#125;=&#123;&#123;value&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;button onclick=&quot;changePerson()&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            person:&#123;                &quot;name&quot;: &quot;zhangsan&quot;,                 &quot;age&quot;: 13,                 &quot;gender&quot;: &quot;男&quot;,                 &quot;address&quot;: &quot;中国&quot;            &#125;        &#125;    &#125;)    function changePerson()&#123;        vm.person = &#123;                &quot;name&quot;: &quot;lisi&quot;,                 &quot;age&quot;: 16,                 &quot;gender&quot;: &quot;女&quot;,                 &quot;address&quot;: &quot;中国&quot;            &#125;    &#125;&lt;/script&gt;\n\n\n注意：由于 v-for优先级比 v-if 高，用在同1个元素上，一定会先执行数组遍历，然后再执行判断，出于性能的考虑，官方并不建议我们连用。\n\nv-on给页面元素绑定事件\n简写 @\n示例：\n&lt;div id=&quot;app&quot;&gt;    &lt;h1 v-if=&quot;show&quot;&gt;        &lt;span style=&quot;color:green&quot;&gt;show=true&lt;/span&gt;    &lt;/h1&gt;    &lt;h1 v-else&gt;        &lt;span style=&quot;color:red&quot;&gt;show=false&lt;/span&gt;    &lt;/h1&gt;    &lt;!-- 直接使用函数名即可 --&gt;    &lt;button v-on:click=&quot;handleClick&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            show:true        &#125;,        methods:&#123;//注意事件处理函数必须定义在methods中            handleClick:function()&#123;                this.show=!this.show;//data中的属性，在函数中可以直接this.访问            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n简写语法：\n&lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;num=&#123;&#123;num&#125;&#125;&lt;/h2&gt;    &lt;!-- 事件处理函数代码简单时，可以直接在事件绑定处写代码 --&gt;    &lt;button @click=&quot;num++&quot;&gt;自增&lt;/button&gt;    &lt;button @click=&quot;decrement&quot;&gt;自减&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            num:1        &#125;,        methods:&#123;            /*                     increment:function()&#123;                this.num--;            &#125;*/            //methods定义函数还可以有如下简写形式 函数名()&#123;&#125;                       increment()&#123;                this.num--;            &#125;        &#125;    &#125;)&lt;/script&gt;\n\nv-if条件渲染(控制节点是否存在)\n\nv-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true 值的时候被渲染。\n\n&lt;div id=&quot;app&quot;&gt;    &lt;h1 v-if=&quot;show&quot;&gt;        &lt;span style=&quot;color:green&quot;&gt;show=true&lt;/span&gt;    &lt;/h1&gt;    &lt;h1 v-if=&quot;!show&quot;&gt;        &lt;span style=&quot;color:red&quot;&gt;show=false&lt;/span&gt;    &lt;/h1&gt;    &lt;button onclick=&quot;handleClick()&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            show:true        &#125;    &#125;)    function handleClick()&#123;        vm.show = !vm.show;    &#125;&lt;/script&gt;\n\nv-elsev-if后还可以添加v-else 指令来表示 v-if 的“else 块”，上面的示例还可以写出如下代码：\n&lt;div id=&quot;app&quot;&gt;    &lt;h1 v-if=&quot;show&quot;&gt;        &lt;span style=&quot;color:green&quot;&gt;show=true&lt;/span&gt;    &lt;/h1&gt;    &lt;h1 v-else&gt;        &lt;span style=&quot;color:red&quot;&gt;show=false&lt;/span&gt;    &lt;/h1&gt;    &lt;button onclick=&quot;handleClick()&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            show:true        &#125;    &#125;)    function handleClick()&#123;        vm.show = !vm.show;    &#125;&lt;/script&gt;\n\nv-show条件渲染(控制节点是否隐藏)\n&lt;div id=&quot;app&quot;&gt;    &lt;h1 v-show=&quot;show&quot;&gt;        &lt;span style=&quot;color:green&quot;&gt;show=true&lt;/span&gt;    &lt;/h1&gt;    &lt;h1 v-show=&quot;!show&quot;&gt;        &lt;span style=&quot;color:red&quot;&gt;show=false&lt;/span&gt;    &lt;/h1&gt;    &lt;button onclick=&quot;handleClick()&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            show:true        &#125;    &#125;)    function handleClick()&#123;        vm.show = !vm.show;    &#125;&lt;/script&gt;\n\n\nv-if 和 v-show 的区别：\n&gt;&lt;div id=&quot;app&quot;&gt;   &lt;h1 v-if=&quot;show&quot;&gt;       &lt;span style=&quot;color:green&quot;&gt;v-if指令&lt;/span&gt;   &lt;/h1&gt;   &lt;h1 v-show=&quot;show&quot;&gt;       &lt;span style=&quot;color:green&quot;&gt;v-show指令&lt;/span&gt;   &lt;/h1&gt;   &lt;button onclick=&quot;handleClick()&quot;&gt;点我&lt;/button&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;   const vm = new Vue(&#123;       el:&quot;#app&quot;,       data:&#123;           show:true       &#125;   &#125;)   function handleClick()&#123;       vm.show = !vm.show;   &#125;&gt;&lt;/script&gt;\n\nv-if 和 v-show 指令展示效果相同，但是打开开发者工具（F12或者ctrl+shift+i)查看Element面板，会发现2者的区别\n\nv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的子组件适当地被销毁和重建。当初始条件为false时，其内部组件不会渲染。\nv-show 就简单得多，它在切换过程中，只是简单地基于 CSS 进行切换。当初始条件为false时，其内部组件也会预先渲染。\n\n一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n\nv-text向指定节点渲染’文本’内容 会替换掉节点里原本的内容\n&lt;div v-text=&quot;name&quot;&gt;text&lt;/div&gt;\n\nv-html 比v-text多了html解析 有安全性问题\n&lt;div v-html=&quot;name&quot;&gt;&lt;h1&gt;html&lt;/h1&gt;&lt;/div&gt;\n\nv-cloak特殊指令，vue接管容器后会自动删除v-cloak 可以配合css实现网速过慢时的 问题\n&lt;div v-cloak &gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;\n\nv-once只在初始化是渲染一次\n&lt;div v-once&gt;n的初始值:&#123;&#123;n&#125;&#125;&lt;/div&gt;&lt;div &gt;n的当前值:&#123;&#123;n&#125;&#125;&lt;/div&gt;\n\nv-pre 跳过vue的解析 加了以后不解析\n&lt;div v-pre &gt;n的当前值:&#123;&#123;n&#125;&#125;&lt;/div&gt;\n\n\ndemo案例&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;label&gt;      &lt;input type=&quot;text&quot; v-model=&quot;value&quot;/&gt;    &lt;/label&gt;    &lt;button type=&quot;submit&quot; @click=&quot;add&quot;&gt;添加&lt;/button&gt;    &lt;ul&gt;      &lt;div v-for=&quot;item in list&quot;&gt;        &lt;li @click=&quot;del(item.key)&quot;&gt;&#123;&#123;item.key&#125;&#125;-&#123;&#123;item.val&#125;&#125;&lt;/li&gt;      &lt;/div&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip=false;  let vue = new Vue(&#123;      el:&quot;#root&quot;      ,data:function ()&#123;          return &#123;              list:[]              ,value:&#x27;&#x27;              ,index:0          &#125;      &#125;      ,methods:&#123;          add: function  ()&#123;              if (!this.value) &#123;                  alert(&#x27;请输入内容&#x27;);                  return;              &#125;              this.list.push(&#123;key:this.index++,val:this.value&#125;);              this.value = &#x27;&#x27;;          &#125;,          del:function (key)&#123;              this.list.forEach(function (item,index,arr)&#123;                  if (item.key == key) &#123;                      arr.splice(index,1);                  &#125;              &#125;);          &#125;      &#125;  &#125;);&lt;/script&gt;&lt;/body&gt;\n\n\n计算属性与监视属性计算属性\n对于任何复杂逻辑，都应当使用计算属性\n\n示例:\n&lt;div id=&quot;example&quot;&gt;  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;\n\nvar vm = new Vue(&#123;  el: &#x27;#example&#x27;,  data: &#123;    message: &#x27;Hello&#x27;  &#125;,  computed: &#123;    // 计算属性的 getter    reversedMessage: function () &#123;      // `this` 指向 vm 实例      return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)    &#125;  &#125;&#125;)\n\n监视属性\n当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。\n\n示例：\n&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;h1&gt;楼下的有一个&#123;&#123;info&#125;&#125;&lt;/h1&gt;    &lt;br/&gt;    &lt;button type=&quot;button&quot; @click=&quot;next&quot;&gt;切换&lt;/button&gt;  &lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip=false;    let vue = new Vue(&#123;        el:&quot;#root&quot;        ,data:function ()&#123;            return &#123;                animal: 0            &#125;        &#125;        ,methods:&#123;            next:function ()&#123;                this.animal++;            &#125;        &#125;        ,computed:&#123;            info:function ()&#123;                let info;                switch (this.animal)&#123;                    case 0: info=&quot;小狗&quot;;                      break;                    case 1: info=&quot;小猫&quot;;                      break;                    case 2: info=&quot;小猪&quot;;                      break;                    case 3: info=&quot;小姐姐&quot;;                      break;                    default:                        info=&quot;小怪兽&quot;;                        this.animal=-1;                        break;                &#125;                return info;            &#125;        &#125;        ,watch:&#123;            info:&#123;                handler (newVal,oldVal)&#123;                    console.log(newVal,oldVal)                &#125;            &#125;        &#125;    &#125;);&lt;/script&gt;\n\n\n组件组件的注册组件的注册方式有2种：全局注册 和 局部注册\n全局注册全局注册的组件，可以在不同的Vue实例中使用。语法如下：\n&lt;script&gt;    Vue.component(&quot;组件名&quot;,&#123;        template:&quot;复用的html片段&quot;,        data:function()&#123;            return &#123;...&#125;//return的对象，类似于创建Vue实例时的data        &#125;,        methods:&#123;            //和定义Vue实例时一样，用于定义函数        &#125;    &#125;)&lt;/script&gt;\n\n局部注册一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。因此，对于一些并不频繁使用的组件，我们会采用局部注册。在Vue实例中添加选项 components 语法如下：\n&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;选择器&quot;,        data:&#123;            //属性        &#125;,        components:&#123;            //注册局部组件            &quot;组件名&quot;:&#123;                template:&quot;复用的html片段&quot;,                data:function()&#123;                    return &#123;...&#125;//return的对象，类似于创建Vue实例时的data                &#125;,                methods:&#123;                    //和定义Vue实例时一样，用于定义函数                &#125;            &#125;        &#125;    &#125;);&lt;/script&gt;\n\n示例：\n&lt;div id=&quot;app&quot;&gt;    &lt;button-counter&gt;&lt;/button-counter&gt;    &lt;button-counter&gt;&lt;/button-counter&gt;    &lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        components:&#123;            &quot;button-counter&quot;:&#123;                template:&quot;&lt;button @click=&#x27;increment&#x27;&gt;你点了我&#123;&#123;count&#125;&#125;次，我记住了&lt;/button&gt;&quot;,                data:function()&#123;                    return &#123;                        count:0                    &#125;                &#125;,                methods:&#123;                    increment()&#123;                        this.count++;                    &#125;                &#125;            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n注册优化当Vue实例中注册的组件比较多时，Vue实例的代码就会变得非常臃肿，不利于代码管理，此时可以将Vue实例参数抽取成变量。\n&lt;script&gt;    const buttonCounter = &#123;        template:&quot;&lt;button @click=&#x27;increment&#x27;&gt;你点了我&#123;&#123;count&#125;&#125;次，我记住了&lt;/button&gt;&quot;,        data:function()&#123;            return &#123;                count:0            &#125;        &#125;,        methods:&#123;            increment()&#123;                this.count++;            &#125;        &#125;    &#125;;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        components:&#123;            &quot;button-counter&quot;:buttonCounter        &#125;    &#125;)&lt;/script&gt;\n\n\n说明：组件注册时，如果组件名和组件变量名同名，还可以简写：\ncomponents:{ buttonCounter:buttonCounter}&#x2F;&#x2F; &#x3D;&#x3D;&gt; 直接只写一个 buttonCounter即可components:{ buttonCounter}\n\n将html片段抽取到template标签中\n当template中的html片段比较复杂时，在组件参数中直接定义html片段非常麻烦，此时可以将html片段抽取到特殊的template标签中。\n&lt;template id=&quot;bc&quot;&gt;    &lt;!-- 再次提示：template标签中也必须只有一个根标签 --&gt;    &lt;button @click=&#x27;increment&#x27;&gt;你点了我&#123;&#123;count&#125;&#125;次，我记住了&lt;/button&gt;&lt;/template&gt;&lt;script&gt;    const buttonCounter = &#123;        template:&quot;#bc&quot;,        data:function()&#123;            return &#123;                count:0            &#125;        &#125;,        methods:&#123;            increment()&#123;                this.count++;            &#125;        &#125;    &#125;;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        components:&#123;            &quot;button-counter&quot;:buttonCounter        &#125;    &#125;)&lt;/script&gt;\n\n组件和is属性（了解）在html标签中使用组件时，受到 HTML 本身的一些限制。比如table、ul、select内部只能出现特定的子标签，如果在这些标签中使用组件，组件无法正确显示。解决方案：使用is属性\n&lt;div id=&quot;app&quot;&gt;    &lt;h4&gt;直接在table中使用table-body组件&lt;/h4&gt;    &lt;table border=&quot;1&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;id&lt;/th&gt;                &lt;th&gt;name&lt;/th&gt;                &lt;th&gt;age&lt;/th&gt;                &lt;th&gt;gender&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;!-- 直接使用组件--&gt;        &lt;table-body&gt;&lt;/table-body&gt;    &lt;/table&gt;    &lt;h4&gt;在table中通过is属性使用table-body组件&lt;/h4&gt;    &lt;table border=&quot;1&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;id&lt;/th&gt;                &lt;th&gt;name&lt;/th&gt;                &lt;th&gt;age&lt;/th&gt;                &lt;th&gt;gender&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;!-- 通过is属性使用组件 --&gt;        &lt;tbody is=&quot;table-body&quot;&gt;&lt;/tbody&gt;    &lt;/table&gt;&lt;/div&gt;    &lt;template id=&quot;table-body&quot;&gt;    &lt;tbody&gt;        &lt;tr v-for=&quot;u in users&quot; :key=&quot;u.id&quot;&gt;            &lt;td&gt;&#123;&#123;u.id&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;u.name&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;u.age&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;u.gender&#125;&#125;&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;&lt;/template&gt;&lt;script&gt;    const tableBody = &#123;        template:&quot;#table-body&quot;,        data()&#123;            return &#123;                users: [                    &#123;&quot;id&quot;:1, &quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 13, &quot;gender&quot;: &quot;男&quot;&#125;,                    &#123;&quot;id&quot;:2, &quot;name&quot;: &quot;小红&quot;, &quot;age&quot;: 13, &quot;gender&quot;: &quot;女&quot;&#125;,                    &#123;&quot;id&quot;:3, &quot;name&quot;: &quot;小绿&quot;, &quot;age&quot;: 4, &quot;gender&quot;: &quot;男&quot;&#125;                ]            &#125;        &#125;    &#125;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        components:&#123;            &quot;table-body&quot;:tableBody        &#125;    &#125;)&lt;/script&gt;\n\n组件嵌套在Vue的设计中，一切都可以看作组件。整个页面可以看作是一个根组件，内部的各块组件可以看作子组件。组件之间自然的会发生嵌套关系\n\n示例：\n&lt;div id=&quot;app&quot;&gt;    &lt;my-table&gt;&lt;/my-table&gt;&lt;/div&gt;&lt;template id=&quot;table-head&quot;&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;id&lt;/th&gt;            &lt;th&gt;name&lt;/th&gt;            &lt;th&gt;age&lt;/th&gt;            &lt;th&gt;gender&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;&lt;/template&gt;&lt;template id=&quot;table-body&quot;&gt;    &lt;tbody&gt;        &lt;tr v-for=&quot;u in users&quot; :key=&quot;u.id&quot;&gt;            &lt;td&gt;&#123;&#123;u.id&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;u.name&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;u.age&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;u.gender&#125;&#125;&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;&lt;/template&gt;&lt;template id=&quot;my-table&quot;&gt;    &lt;table border=&quot;1&quot; align=&quot;center&quot;&gt;        &lt;thead is=&quot;table-head&quot;&gt;&lt;/thead&gt;        &lt;tbody is=&quot;table-body&quot;&gt;&lt;/tbody&gt;    &lt;/table&gt;&lt;/template&gt;&lt;script&gt;    var tableHead = &#123;        template:&quot;#table-head&quot;    &#125;    var tableBody = &#123;        template:&quot;#table-body&quot;,        data:function()&#123;            return &#123;                users: [                    &#123;&quot;id&quot;:1, &quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 13, &quot;gender&quot;: &quot;男&quot;&#125;,                    &#123;&quot;id&quot;:2, &quot;name&quot;: &quot;小红&quot;, &quot;age&quot;: 13, &quot;gender&quot;: &quot;女&quot;&#125;,                    &#123;&quot;id&quot;:3, &quot;name&quot;: &quot;小绿&quot;, &quot;age&quot;: 4, &quot;gender&quot;: &quot;男&quot;&#125;                ]            &#125;        &#125;    &#125;    //使用局部注册，需要将子组件注册到父组件中    var myTable =&#123;        template:&quot;#my-table&quot;,        components:&#123;            &quot;table-head&quot;:tableHead,            &quot;table-body&quot;:tableBody        &#125;    &#125;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        components:&#123;            &quot;my-table&quot;:myTable        &#125;    &#125;);&lt;/script&gt;\n\n\n事实上，虽然 new Vue() 没有显式的使用组件的语法，但它本质上也是一个父组件。\n\n组件通信父传子：props通常父组件的模板中包含子组件，父组件要正向地向子组件传递数据或参数，子组件接收到后根据参数的不同来渲染不同的内容或执行操作。这个正向传递数据的过程就是通过props来实现的。\n比如在之前的表格案例中，table-body子组件展示的数据是定义在子组件自个身上的，这么做虽有效果，但降低了该组件的复用价值，更好的做法：子组件中不定义数据，而是由使用它的父组件传递。此时，需要使用 props完成父组件向子组件的数据传递。\n语法：//1.定义子组件中添加props属性const 组件 = &#123;    template:&quot;html片段&quot;,    props:[&quot;自定义参数名&quot;,...]&#125;//2 使用组件时，为组件添加 自定义参数名 同名的属性&lt;组件 :自定义参数名=”值&quot;&gt;&lt;/组件&gt;\n\n示例：\n&lt;div id=&quot;app&quot;&gt;    &lt;my-table :us=&quot;users&quot;&gt;&lt;/my-table&gt;&lt;/div&gt;&lt;template id=&quot;my-table&quot;&gt;    &lt;table border=&quot;1&quot; align=&quot;center&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;id&lt;/th&gt;                &lt;th&gt;name&lt;/th&gt;                &lt;th&gt;age&lt;/th&gt;                &lt;th&gt;gender&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr v-for=&quot;u in us&quot; :key=&quot;u.id&quot;&gt;                &lt;td&gt;&#123;&#123;u.id&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;u.name&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;u.age&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;u.gender&#125;&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;    &lt;/template&gt;&lt;script&gt;    var myTable = &#123;        template:&quot;#my-table&quot;,        props:[&quot;us&quot;]    &#125;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            users: [                &#123;&quot;id&quot;:1, &quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 13, &quot;gender&quot;: &quot;男&quot;&#125;,                &#123;&quot;id&quot;:2, &quot;name&quot;: &quot;小红&quot;, &quot;age&quot;: 13, &quot;gender&quot;: &quot;女&quot;&#125;,                &#123;&quot;id&quot;:3, &quot;name&quot;: &quot;小绿&quot;, &quot;age&quot;: 4, &quot;gender&quot;: &quot;男&quot;&#125;            ]        &#125;,        components:&#123;            &quot;myTable&quot;:myTable        &#125;    &#125;);&lt;/script&gt;\n\n\n\n子传父：$emit父组件的模板中包含子组件，那么经常会出现子组件的状态发生变化时，要通知到父组件。所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。如下所示：\n&lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;&#123;&#123;num&#125;&#125;&lt;/h2&gt;    &lt;!-- 父组件向子组件传递数据 count=num子组件中修改count值，不能修改父组件的num--&gt;    &lt;counter :count=&quot;num&quot;&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&quot;counter&quot;,&#123;        template:`&lt;div&gt;&lt;button @click=&quot;increment&quot;&gt;点我自增&lt;/button&gt;&lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;&lt;button @click=&quot;decrement&quot;&gt;点我自减&lt;/button&gt;    &lt;/div&gt;`,        props:[&quot;count&quot;],        methods:&#123;            increment()&#123;                this.count++;            &#125;,            decrement()&#123;                this.count--;            &#125;        &#125;    &#125;)    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            num:0        &#125;    &#125;)&lt;/script&gt;\n\n所以，当需要子传父的时候，Vue采用事件放射的方式完成。\n\n在子组件中执行 $emit(“父组件的自定义事件”)通知父组件，并发送数据\n父组件中定义自定义事件处理函数，并接收数据\n\n&lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;&#123;&#123;num&#125;&#125;&lt;/h2&gt;    &lt;!-- 2 绑定自定义事件处理函数，监听子组件的事件触发 change-count        当子组件触发事件后，执行handleChange事件处理函数，        $emit发送的数据将成为handleChange的实参    --&gt;    &lt;counter :count=&quot;num&quot; @change-count=&quot;handleChange&quot;&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&quot;counter&quot;,&#123;        template:`            &lt;div&gt;                &lt;button @click=&quot;increment&quot;&gt;点我自增&lt;/button&gt;                &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;                &lt;button @click=&quot;decrement&quot;&gt;点我自减&lt;/button&gt;             &lt;/div&gt;`,        props:[&quot;count&quot;],        methods:&#123;            increment()&#123;                this.count++;                //1 子组件中通过$emit触发父组件中的自定义事件，并发送数据                this.$emit(&quot;change-count&quot;,this.count);            &#125;,            decrement()&#123;                this.count--;                //1 子组件中通过$emit触发父组件中的自定义事件，并发送数据                this.$emit(&quot;change-count&quot;,this.count);            &#125;        &#125;    &#125;)    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            num:0        &#125;,        methods:&#123;            handleChange(value)&#123;                this.num = value;            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n\nVueRouter\n什么是路由（这里不要死抠字眼，尝试从字面上理解，只是一个名词而已，重点是理解名词代表的技术解决什么问题）？生活中最能体现路由功能的是路由器，路由器的作用：互联网中的计算机，必须要通过路由器根据目标机器ip地址，将数据转发到目标机器。\n\n路由示例\n页面引入 vue-router.js\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue-2.6.12.js&quot;&gt;&lt;/script&gt;&lt;!--注意引入顺序： vue-router.js 必须在vue.js之后引入 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue-router-3.4.9.js&quot;&gt;&lt;/script&gt;\n\n定义组件\nconst loginForm = &#123;    template:&quot;#login-form&quot;&#125;const registerForm = &#123;    template:&quot;#register-form&quot;&#125;\n\n\n\n创建 VueRouter对象，配置路由匹配规则\n//router对象var router = new VueRouter(&#123;    routes:[        &#123;            name:&quot;login&quot;,//路由名称            path:&quot;/login&quot;,//路由路径            component:loginForm//要路由到的组件        &#125;,        &#123;name:&quot;register&quot;,path:&quot;/register&quot;,component:registerForm&#125;    ]&#125;);\n\n\n\n向Vue实例中配置router\nconst vm = new Vue(&#123;    el:&quot;#app&quot;,    //router:router //如果路由对象名也叫router，则可以省略:router    router&#125;)\n\n\n\n在页面上使用路由\n&lt;div id=&quot;app&quot;&gt;    &lt;!-- 超链接的href必须以#开头 --&gt;    &lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt;    &lt;a href=&quot;#/register&quot;&gt;注册&lt;/a&gt;    &lt;hr&gt;    &lt;!-- router-view是路由的锚点，也就是路由到的组件显示的地方 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\n\nrouter-link和redirectrouter-link\n\nrouter-link标签用于代替a标签，定义跳转超链接\n\n&lt;div id=&quot;app&quot;&gt;    &lt;!-- 超链接的href必须以#开头 --&gt;    &lt;!--&lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt;    &lt;a href=&quot;#/register&quot;&gt;注册&lt;/a&gt;--&gt;    &lt;!-- to属性配置跳转路径，不用添加#前缀 --&gt;    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;    &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;    &lt;hr&gt;    &lt;!-- router-view是路由的锚点，也就是路由到的组件显示的地方 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\n\nredirect\n\nredirect属性用在路由上，比如在a路由上配置redirect:b路由的路径，当访问a时会自动重定向到b。通常用于配置页面的默认路由地址\n\nvar router = new VueRouter(&#123;    routes:[        &#123;name:&quot;default&quot;,path:&quot;/&quot;,redirect:&quot;/login&quot;&#125;,        &#123;            name:&quot;login&quot;,//路由名称            path:&quot;/login&quot;,//路由路径            component:loginForm//要路由到的组件        &#125;,        &#123;name:&quot;register&quot;,path:&quot;/register&quot;,component:registerForm&#125;    ]&#125;);\n\n嵌套路由实际生活中的应用界面，通常由多层嵌套的组件组合而成。当我们路由到某一个组件后，还经常需要在该组件中继续路由到其子组件，这就需要使用Vue的嵌套路由。比如：当我们路由到登录组件后，又分为手机验证码登录和 账户名密码登录 2个子组件。\n语法：const 子组件 = &#123;    template:&quot;子组件标签&quot;&#125;const 父组件 = &#123;    tempalate:`        &lt;router-link to=&quot;/父组件路径/子组件的路径&quot;&gt;链接1&lt;/router-link&gt;        &lt;router-view&gt;&lt;/router-view&gt;    `&#125;const router = new VueRouter(&#123;    routes:[        &#123;            path:&quot;/组件路径&quot;,            component:父组件对象,            children:[//设置子路由信息                &#123;                    path:&quot;子组件路径&quot;,//  不以/开头                    component:子组件                &#125;            ]        &#125;    ]&#125;)\n\n示例：\n&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;        &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;        &lt;hr&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;template id=&quot;phone-login-form&quot;&gt;        &lt;form action=&quot;&quot;&gt;            手机号: &lt;input type=&quot;number&quot; name=&quot;phone&quot; &gt; &lt;br&gt;            验证码: &lt;input type=&quot;password&quot; name=&quot;code&quot;&gt; &lt;br&gt;            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;        &lt;/form&gt;    &lt;/template&gt;    &lt;template id=&quot;account-login-form&quot;&gt;        &lt;form action=&quot;&quot;&gt;            用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br&gt;            密码: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;br&gt;            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;        &lt;/form&gt;    &lt;/template&gt;    &lt;template id=&quot;register-form&quot;&gt;        &lt;form action=&quot;&quot;&gt;            用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br&gt;            密码: &lt;input type=&quot;password&quot; name=&quot;pwd1&quot;&gt; &lt;br&gt;            确认密码: &lt;input type=&quot;password&quot; name=&quot;pwd2&quot; &gt; &lt;br&gt;            &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;        &lt;/form&gt;    &lt;/template&gt;    &lt;script&gt;        const registerForm = &#123;            template:&quot;#register-form&quot;        &#125;        const phoneLogin = &#123;            template:&quot;#phone-login-form&quot;        &#125;        const accountLogin = &#123;            template:&quot;#account-login-form&quot;        &#125;        const loginForm = &#123;            template:`                &lt;div&gt;                    &lt;router-link to=&quot;/login/phone&quot;&gt;手机验证码登录&lt;/router-link&gt;                    &lt;router-link to=&quot;/login/account&quot;&gt;用户名密码登录&lt;/router-link&gt; &lt;br&gt; &lt;br&gt;                    &lt;router-view&gt;&lt;/router-view&gt;                &lt;/div&gt;            `        &#125;        const router = new VueRouter(&#123;            routes:[                &#123;path:&quot;/&quot;,redirect:&quot;/register&quot;&#125;,                &#123;path:&quot;/register&quot;,component:registerForm&#125;,                &#123;                    path:&quot;/login&quot;,                    component:loginForm,                    children:[                        &#123;path:&quot;phone&quot;,component:phoneLogin&#125;,                        &#123;path:&quot;account&quot;,component:accountLogin&#125;                    ]                &#125;            ]        &#125;)        const vm = new Vue(&#123;            el:&quot;#app&quot;,            router        &#125;)    &lt;/script&gt;&lt;/body&gt;\n\n路由组件传参通过路由导航到组件时，有时需要传递参数。\nquery传参&lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/user?name=李栓蛋&amp;age=38&quot;&gt;用户管理&lt;/router-link&gt;    &lt;router-link :to=&quot;&#123;path:&#x27;/user&#x27;,query:&#123;name:&#x27;王花花&#x27;,age:28&#125;&#125;&quot;&gt;用户管理&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt;    const user = &#123;        template:`&lt;div&gt;                    &lt;div&gt;我叫&#123;&#123;$route.query.name&#125;&#125;&lt;/div&gt;                    &lt;div&gt;今年&#123;&#123;$route.query.age&#125;&#125;&lt;/div&gt;                &lt;/div&gt;`    &#125;    const router = new VueRouter(&#123;        routes:[            &#123;path:&quot;/user&quot;,component:user&#125;        ]    &#125;)    const vm = new Vue(&#123;        el:&quot;#app&quot;,        router    &#125;)&lt;/script&gt;\n\nparams传参&lt;div id=&quot;app&quot;&gt;     &lt;router-link to=&quot;/product/macbookair&quot;&gt;商品1&lt;/router-link&gt;     &lt;router-link :to=&quot;&#123;name:&#x27;product&#x27;,params:&#123;name:&#x27;macbookpro&#x27;&#125;&#125;&quot;&gt;商品2&lt;/router-link&gt;        &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt;    const product = &#123;        template:`&lt;div&gt;                    &lt;div&gt;商品名：&#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt;                  &lt;/div&gt;`    &#125;    //通过:参数名的方式匹配数据    const router = new VueRouter(&#123;        routes:[            &#123;name:&quot;product&quot;,path:&quot;/product/:name&quot;,component:product&#125;        ]    &#125;)    const vm = new Vue(&#123;        el:&quot;#app&quot;,        router    &#125;)&lt;/script&gt;\n\n编程式的路由导航除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。\n语法：router.push(location, onComplete?, onAbort?)\n\n注意：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。\n\n\n\n声明式\n编程式\n\n\n\n&lt;router-link :to=&quot;...&quot;&gt;\nrouter.push(...)\n\n\n该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n// 字符串router.push(&#x27;/login&#x27;)// 对象router.push(&#123; path: &#x27;/login&#x27; &#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &#x27;register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125;&#125;)\n\n示例：在注册后，立刻导航到登录\n&lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;    &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;    &lt;hr&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id=&quot;login-form&quot;&gt;    &lt;form action=&quot;&quot;&gt;        用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br&gt;        密码: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;br&gt;        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;    &lt;/form&gt;&lt;/template&gt;&lt;template id=&quot;register-form&quot;&gt;    &lt;form action=&quot;&quot; @submit.prevent=&quot;handleRegister&quot;&gt;        用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br&gt;        密码: &lt;input type=&quot;password&quot; name=&quot;pwd1&quot;&gt; &lt;br&gt;        确认密码: &lt;input type=&quot;password&quot; name=&quot;pwd2&quot; &gt; &lt;br&gt;        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;    &lt;/form&gt;&lt;/template&gt;&lt;script&gt;    const loginForm = &#123;        template:&quot;#login-form&quot;    &#125;    const registerForm = &#123;        template:&quot;#register-form&quot;,        methods:&#123;            handleRegister()&#123;                alert(&quot;添加成功&quot;);                this.$router.push(&#123;path:&quot;/login&quot;&#125;)            &#125;        &#125;    &#125;    var router = new VueRouter(&#123;        routes:[            &#123;name:&quot;default&quot;,path:&quot;/&quot;,redirect:&quot;/login&quot;&#125;,            &#123;                name:&quot;login&quot;,//路由名称                path:&quot;/login&quot;,//路由路径                component:loginForm//要路由到的组件            &#125;,            &#123;name:&quot;register&quot;,path:&quot;/register&quot;,component:registerForm&#125;        ]    &#125;);    const vm = new Vue(&#123;        el:&quot;#app&quot;,        components:&#123;            loginForm,            registerForm        &#125;,        //router:router //如果路由变量名也叫router，则可以省略:router        router    &#125;)&lt;/script&gt;\n\n\nVue的生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板、销毁等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。\n生命周期图示下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。\n\n钩子函数每个 Vue 实例在被创建时都要经过一系列的初始化过程。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这些函数在生命周期的不同阶段自动触发执行，这给了用户在不同阶段添加自己的代码的机会。\n\n\n\n生命周期钩子\n含义\n\n\n\nbeforeCreate（vue对象创建前）\n组件实例刚被创建，组件属性计算之前，此时不能访问属性\n\n\ncreated（创建后）\n组件实例创建完，属性可以访问，但是还不能通过 $el 访问DOM\n\n\nbeforeMount(加载前)\n模板编译、挂载之前，可以通过 $el 访问渲染前的DOM\n\n\nmounted（载入后）\n模板编译、挂载之后，可以通过 $el访问渲染前的DOM\n\n\nbeforeUpdate（更新前）\n组件更新之前，可以获取组件更新前的DOM\n\n\nupdated（更新后）\n组件更新之后，可以获取组件更新后的DOM\n\n\nbeforeDestroy（销毁前）\n组件销毁前调用\n\n\ndestroyed（销毁后）\n组件销毁后调用\n\n\n通过以下案例，演示下各个钩子函数的使用：\n&lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;    &lt;button @click=&quot;changeMsg&quot;&gt;点我修改msg&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    const vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            msg:&quot;hell vue&quot;        &#125;,        methods:&#123;            changeMsg()&#123;                this.msg = &quot;hello baizhi&quot;;            &#125;        &#125;,        beforeCreate:function()&#123;            // alert(&quot;beforeCreate...&quot;);            console.log(&quot;beforeCreate...&quot;);            console.log(this.$el);//undefined            console.log(this.msg);//undefined        &#125;,        created:function()&#123;            // alert(&quot;created...&quot;);            console.log(&quot;created...&quot;);            console.log(this.$el);//undefined            console.log(this.msg);//hello vue        &#125;,        beforeMount:function()&#123;            // alert(&quot;beforeMount...&quot;);            console.log(&quot;beforeMount...&quot;);            console.log(this.$el);//加载前的标签，就是原始代码,插值表达式、事件绑定都还没解析            console.log(this.msg);//hello vue        &#125;,        mounted:function()&#123;            // alert(&quot;mounted...&quot;);            console.log(&quot;mounted...&quot;);            console.log(this.$el);//加载后的标签，插值表达式、事件绑定均已解析            console.log(this.msg);//hello vue        &#125;,        beforeUpdate:function()&#123;            // alert(&quot;beforeUpdated...&quot;);            console.log(&quot;beforeUpdated...&quot;);            console.log(this.$el.innerHTML);//更新前的DOM            console.log(this.msg);//hello baizhi        &#125;,        updated:function()&#123;            // alert(&quot;updated...&quot;);            console.log(&quot;updated...&quot;);            console.log(this.$el.innerHTML);//更新后的DOM            console.log(this.msg);//hello baizhi        &#125;,        beforeDestroy:function()&#123;//在console中执行vm.$destroy()触发，开发时很少关注            // alert(&quot;destroyed...&quot;);            console.log(&quot;beforeDestroy...&quot;);            console.log(this.$el);            console.log(this.msg);        &#125;,        destroyed:function()&#123;            // alert(&quot;destroyed...&quot;);            console.log(&quot;destroyed...&quot;);            console.log(this.$el);            console.log(this.msg);        &#125;    &#125;)&lt;/script&gt;\n\n\n一般地，我们会在 created 钩子函数中，从服务端获取数据，并对数据进行初始化。\n\n","tags":["vue"]},{"title":"css","url":"/2019/03/13/css/","content":"\n层叠样式表（Cascading Style Sheet，简称：CSS）是为网页添加样式的代码。\n\nCss的语法/*选择器&#123;    样式名：样式值;    样式名：样式值;&#125;*//*样式名    Color:red;    Font-size:20px;*//*标签选择器：P&#123;    Color:red;    Font-size:20px;&#125;被p标签包含的标签内容，字号为20像素。字体颜色为红色。*/\n\nCss中的选择器\n标签选择器：直接用标签名\n\n/* &lt;h1/&gt; */h1 &#123;  color: red;&#125;\n\n\n类选择器：.类名\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;style&gt;    .demo&#123;        color: aqua;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 class=&quot;demo&quot;&gt;1111&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nId选择器：#id名\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;style&gt;    #demo&#123;        color: aqua;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 id=&quot;demo&quot;&gt;1111&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nId选择和class选择器的区别是id的值不重复，class的值可以重复。\n\n\n复杂的选择器\n交集选择器（两个选择器紧挨着）\n并集选择器（连个选择器之间用逗号分隔）\n后代选择器（两个选择器之间用空格分隔）\n\n\n\n引入方式\n行内引入: 在开始标签里面增加style属性\n内部引入: 在head里面增加style标签\n外部引入:借助&lt;link/&gt;标签\n\n常见的样式边框border​\t每一个标签都是有区域的。我们可以通过border样式把标签的区域给显示出来。\n​\tborder：边框的粗细 边框的样式（实线虚线） 边框的颜色\n外边距margin​\t两个标签的边框之间的距离就是外边距\n内边距padding​\t一个标签边框和标签内容之间的距离\n背景background​\t在一个标签的border边框里面的内容我们可以设置背景样式。\n\n​\tBackground-color：设置背景颜色的。\n​\tBackground-image:设置背景图片的。\n​\tBackground-position：设置背景图片的位置。\n​\tBackground-repeat：设置背景图片是否重复。\n\n文本样式\nColor:字体颜色\nText-align：文本的水平位置。\nLine-height:行高\nText-decoration：设置装饰线\n\n伪类样式a:hover&#123;&#125;\n\n当光标悬浮到超链接上时。\n浮动样式\n做页面布局：\n\n\nWidth：元素的宽度。\nHeight:元素的高度。\nClear：设置当前元素的左边和右边都没有浮动元素。\n\n","tags":["css"]},{"title":"git常用命令","url":"/2020/04/15/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"\n整理本人日常用到的git命令，并非全部git命令\n\ngit remotegit remote #命令列出所有远程主机git remote -v #列出所有远程主机并展示远程主机的网址git remote show &lt;主机名&gt; #查看远程分支的详细状况git remote add &lt;主机名&gt; &lt;网址&gt; #添加远程主机名git remote rm &lt;主机名&gt; # 删除远程主机git remote rename &lt;原主机名&gt; &lt;新主机名&gt; # 修改远程主机名\n\ngit branchgit branch #查看本地分支 现在所在的分支会有 * 号标注git branch -r #查看远程分支git branch -a #查看所有分支（本地+远程）\n\ngit checkoutgit checkout 分支名 #切换到指定分支#指定本地分支切出新分支并切换。不指定分支时根据当前分支切新分支git checkout -b newBrach 远程分支/本地已有分支\n\ngit mergegit merge 本地分支名 #合并本地分支#合并本地分支，用于取 fetch 后的内容git merge 远程分支/本地分支\n\ngit pull#把指定远程主机名远程分支的内容拉取到指定的本地分支git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;#把指定分支内容拉取到当前本地分支，相当于先 fetch 再 mergegit pull &lt;远程主机名&gt; &lt;远程分支名&gt;\n\ngit push#把指定本地分支的 commit 推到指定的远程主机远程分支上git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;#把本地分支推送与之存在&quot;追踪关系&quot;的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。git push &lt;远程主机名&gt; &lt;远程分支名&gt; #删除指定的远程分支，等同于推送一个空的本地分支到远程分支git push &lt;远程主机名&gt;:&lt;远程分支名&gt;#指定默认主机，下次直接 git push 即可git push -u &lt;远程主机名&gt; &lt;本地分支名&gt;\n\ngit resetgit reset --soft HEAD^：将最近一次提交节点的提交记录回退到暂存区git reset --mixed HEAD^：将最近一次提交节点的提交记录回退到工作区git reset --hard HEAD^：将最近一次提交节点的提交记录全部清除\n\ngit revertgit revert HEAD ：撤销前一次 commitgit revert HEAD^ ：撤销前前一次 commitgit revert commit + (commit id)： 撤销指定的版本，撤销也会作为一次提交进行保存。\n\ngit清除缓存git rm -r --cached .git add .git commit -m &#x27;update .gitignore&#x27;\n\n","tags":["git"]},{"title":"Hello World","url":"/2019/01/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"html","url":"/2019/03/05/html/","content":"\nHTML\n​\thyperText markup language 超文本标记语言\n​\t超文本 : 可以显示文字的颜色，图片，点击超链接。\n​\t标记语言 : 其它的标记语言xml。文档中都是有标签构成的\n\nHelloWorld&lt;html&gt;&lt;head&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    HelloWold&lt;/body&gt;&lt;/html&gt;\n\n结构介绍\n标签：在html里面被&lt;&gt;括起来的叫做标签。\n开始标签：&lt;标签名&gt;\n结束标签：&lt;&#x2F;标签名&gt;被这个括起来的就是结束标签\n根标签：html文档中的第一个标签我们称为根标签。\n子标签：标签内部的标签，就是子标签。\n父标签：标签外面被套着的标签就是父标签。\n标签内容：开始标签和结束标签之间的文本内容，我们称为标签内容。\n自闭和标签：没有标签内容，开始标签和结束标签合二为一。&lt;meta/&gt;``&lt;br/&gt;``&lt;img/&gt;\n标签属性：写在开始标签里面 标签名结束后来一个空格， key&#x3D;值\n一个标签是有四部分组成。开始标签，标签属性（可选），标签内容，结束标签（自闭和标签是没有）。\n\n常见标签标题标签&lt;h1&gt;H1&lt;/h1&gt;&lt;h2&gt;H2&lt;/h2&gt;&lt;h3&gt;H3&lt;/h4&gt;&lt;h4&gt;H4&lt;/h4&gt;&lt;h5&gt;H5&lt;/h5&gt;&lt;h6&gt;H6&lt;/h6&gt;\n\n\n\n换行标签&lt;br/&gt;\n\n\n\n段落标签&lt;p&gt;\n\n\n\n水平线标签&lt;hr/&gt;\n\n\n\n图片标签&lt;img src=&quot;&quot; height=&quot;&quot; width=&quot;&quot;/&gt;\n\n\n属性src表示的是引用图片的地址。Height是图片的高度，width是图片的宽度。单位是px像素。\n\n超链接标签&lt;a href=&quot;&quot; target=&quot;&quot;&gt;点我&lt;/a&gt;\n\n\nhref表示点击超链接后要跳转的页面，target是打开新页面的方式。\n\n无序列表&lt;ul type=&quot;&quot;&gt;    &lt;li&gt;苹果&lt;/li&gt;    &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt;\n\n\nul是列表，li是列表项。Type属性表示列表项前面的符号。Desc，circle，square\n\n有序列表&lt;ol type=&quot;&quot;&gt;    &lt;li&gt;苹果&lt;/li&gt;    &lt;li&gt;香蕉&lt;/li&gt;&lt;/ol&gt;\n\n\nol表示有序列表，li表示列表项。Type属性表示有序列表项前面的符号，1，a，i\n\n注释&lt;!--  html注释   --&gt;\n\n\n\nTable表格\ntable标签：表示一个表格。属性：border表格的边框，cellspacing表格边框和单元格之间的间隙。align表示表格的水平位置，值有left,center,right。bgcolor属性表示的是表格的背景颜色。\ntr标签：表格里面的行标签。一个tr表示一行。必须作为table标签的子标签。在tr里面是不能之间写表格里面要展示的内容的。表格要展示的内容必须写在td里面。\ntd标签：表格的单元格标签。一个td就表示一个单元格。属性：align单元格的内容的水平位置。colspan让单元格跨列。rowspan让单元格跨行。\n\n注意事项：\n\ntd的父标签必须是tr，tr的父标签一定是table。\n表格要展示的内容必须写在td里面。\n单元格跨行或者跨列后，相应位置的单元格个数应该减少。\n\nform表单\nForm标签是表单标签，所有的表单元素都要写在form标签里面。\nForm标签有一个action属性，他的含义是点击提交按钮后要跳转的页面。\n为了页面更加的整齐，form表单会跟表格标签在一块搭配使用\n\n表单元素文本框&lt;input type=&quot;text&quot; value=&quot;&quot;/&gt;  \n\n\nvalue是文本框的默认值。\n\n密码框&lt;input type=&quot;password&quot; value=&quot;&quot;/&gt;\n\n提交按钮&lt;input type=&quot;submit&quot; value=&quot;&quot;/&gt; \n\n\nvalue属性是按钮上显示的文字。\n\n单选框&lt;input type=&quot;radio&quot;/&gt; \n\n\n要想使多个单选框之间互斥，需要在这多个单选框里面加上\t相同的name属性。默认选中的单选框上面需要添加checked&#x3D;”checked”属性。\n\n复选框&lt;input type=&quot;checkbox&quot; checked=&quot;checkedd&quot;/&gt;\n\n大文本框&lt;textarea rows=&quot;&quot; cols=&quot;&quot;&gt;&lt;/textarea&gt; \n\n\nrows表示行数，cols表示列数。大文本框中\t的默认内容要写成标签内容。\n\n下拉列表框&lt;select&gt;&lt;/select&gt;\n\n下拉选项&lt;option selected=&quot;selected&quot;&gt;高中&lt;/option&gt;  \n\n\nselected是否默认被选中。\n\n文件域&lt;input type=&quot;file&quot;/&gt;\n\n按钮&lt;input type=”reset” value=”重置按钮”/&gt;&lt;input type=”button” value=”普通按钮”/&gt;\n\n","tags":["html"]},{"title":"jQuery","url":"/2019/03/14/jQuery/","content":"\n​\t\tjQuery 是一个快速、小型且功能丰富的 JavaScript 库。它使 HTML 文档遍历和操作、事件处理、动画和 Ajax 之类的事情变得更加简单，它具有易于使用的 API，可在多种浏览器中工作。jQuery 结合了多功能性和可扩展性，改变了数百万人编写 JavaScript 的方式。\n\nHelloWorld&lt;div id=”t1”&gt;HelloWorld!&lt;/div&gt;\n\nvar s1 =$(“#t1”).html();alert(s1);\n\nDOM对象和JQuery对象的区别\nDOM对象是JavaScript的原生对象。\n\n//obj就是一个DOM对象var obj = document.getElementById(“t1”);\n\n\njQuery对象是jQuery库自己封装的对象。\n\nvar obj= $(“#t1”);\n\n\njQuery对象可以调用自己库中提供的方法，JavaScript对象不可以。同样jQuery对象也不能调用JavaScript原生的对象和方法\n\nJavaScript原生对象和JQuery对象之间可以互相转换\n\nJavaScript原生对象转换成jQuery对象: $(JavaScript对象)\njQuery对象转换成JavaScript原生对象: jQuery对象[0]\n\n\n\n事件\n选择器\n基本选择器\n\n\nID选择器(#id)、标签选择器(标签名)、类选择器(.class)、并集选择器(选择器1,选择器2,选择器3)\n\n\n属性选择器\n\n//获取包含name属性的标签$(“[name]”).css(“color”,”red”);//获取包含name=abc属性的标签$(“[name=’abc’]”).css(“color”,”red”);\n\n\n表单对象属性选择器\n\n//获取表单中$(“:checked”);\n\n常用DOM操作方法\nprop()\ncss()\nhtml()\naddClass()\nval()\nappend(); 追加一个子标签(在最后)\nprepend();  添加一个子标签(在最前面)\nafter(); 追加一个兄弟标签(在之后)\nbefore();   添加一个兄弟标签(在之前)\nremove()  删除指定标签对象\nchildren();  所有孩子标签\nnext();    下一个兄弟\nprev();   上一个兄弟\nparent();  父节点\nsiblings()   获取所有同辈元素\nshow();     显示\nhide();      隐藏\nfadeIn()     淡入\nfadeOut();    淡出\n\n","tags":["javascript","jQuery"]},{"title":"js基础","url":"/2019/03/11/js%E5%9F%BA%E7%A1%80/","content":"HelloWorld//三种输出方式// 弹窗alert(&quot;HelloWorld&quot;)//  向页面输出内容document.write(&quot;HelloWorld&quot;)// 控制台打印console.log(&quot;HelloWorld&quot;)\n\n\n\n变量//字符串 js不区分字符和字符串var a = &quot;str1&quot;;var b = &#x27;str2&#x27;;//数字 js不区分 整型和浮点数var c = 12;var d = 12.3;//booleanvar e = true;var f = false;//null 变量默认值不是nullvar g = null; // undefined (未定义 变量的默认值)var h; \n\n\n\n运算符\n算术运算符：+ - * / % \n\n赋值运算符：= += -= *= /= %= \n\n关系运算符：== != &lt; &gt; &lt;= &gt;= \n\n逻辑运算符：&amp;&amp; || !  \n\n三目运算： 条件? v1 : v2\n\ntypeof 运算符\ntypeof &quot;John&quot;                 // 返回 &quot;string&quot;typeof 3.14                   // 返回 &quot;number&quot;typeof NaN                    // 返回 &quot;number&quot;typeof false                  // 返回 &quot;boolean&quot;typeof [1,2,3,4]              // 返回 &quot;object&quot;typeof &#123;name:&#x27;John&#x27;, age:34&#125;  // 返回 &quot;object&quot;typeof new Date()             // 返回 &quot;object&quot;typeof function () &#123;&#125;         // 返回 &quot;function&quot;typeof myCar                  // 返回 &quot;undefined&quot; *typeof null                   // 返回 &quot;object&quot;\n\n分支结构//if分支if()&#123;&#125;if()&#123;&#125;else&#123;&#125;//switch分支switch(v)&#123;  case 1: ... break;  case 2: ... break;  case 3: ... break;  default: ... break;  &#125;\n\n\n\n循环结构\nwhile(){}\ndo{} while();\nfor(var i&#x3D;0;i&lt;10;i++){}\n\n函数\n定义一个函数\n\nfunction 函数名 （参数列表）{\n[return]\n}\n\n\n调用函数\n// 定义一个有参 有返回值的函数function fun3(x,y)&#123;    console.log(x+&quot;--&quot;+y);    return x+y;&#125;//调用fun3let fun = fun3(4,4.5);console.log(fun)\n\n变量可以存储函数\n\n匿名函数\n\n函数可以作为参数\n// 函数做变量let fun4 = function (fun) &#123;    console.log(&quot;fun4-start&quot;);    fun();    console.log(&quot;fun4-end&quot;);&#125;fun4(function ()&#123;    console.log(&quot;匿名函数&quot;)&#125;);\n\n内置对象数组 Array//定义数组let arr=[1,2,3,4]let arr2= new Array();arr2.push(1);arr2[1]=2;arr2.push(3);//遍历数组for (var i=0;i&lt;arr2.length;i++)&#123;    console.log(arr2[i]);&#125;for (var v in arr)&#123;    console.log(arr[v]);&#125;\n\n字符串String//Stringvar str=&quot;helloWorld  &quot;;//获取下标为1的字符console.log(str.charAt(1));// 跟据W 拆分字符串成数组console.log(str.split(&quot;W&quot;));//除字符串两侧的空白字符或其他预定义字符console.log(str.trim());//截取字符串 下标0开始，截取五个字符console.log(str.substring(0,5));//转大写console.log(str.toUpperCase());//转小写console.log(str.toUpperCase().toLowerCase());//字符长度console.log(str.length);\n\n时间Datevar date= new Date();//时间戳console.log(date.getTime());//年console.log(date.getFullYear());//月 系统 0-11console.log(date.getMonth()+1);//日console.log(date.getDate());//时console.log(date.getHours());//分console.log(date.getMinutes());//秒console.log(date.getSeconds());//时间差 天var d1 = new Date(2019,11,11);var d2 = new Date(2018,11,11);console.log((d1.getTime()-d2.getTime())/1000/60/60/24);\n\n\n\nJS对象  // 创建对象var obj1 = &#123;    name:&quot;zhangsan&quot;    ,age:18    ,sex:&quot;未知&quot;    ,fun : function() &#123;        return this.name + &quot; &quot; + this.age+&quot; &quot;+this.sex;    &#125;&#125;var obj2 = new Object();obj2.name=&quot;lisi&quot;;obj2.age=18;obj2.sex=&quot;未知&quot;;//访问 JavaScript 属性console.log(obj1.name);console.log(obj1[&quot;age&quot;]);console.log(obj1.fun());// for...in 循环 遍历对象属性for (o in obj2) &#123;    console.log(obj2[o]);&#125;\n","tags":["html","javascript"]},{"title":"homebrew","url":"/2020/05/11/homebrew/","content":"\nHomebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。\n\n安装过程参考官网\n/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n\n常用命令# 查询软件brew search 软件名# 安装软件brew install 软件名# 后台运行的软件（重启之后可以自动启动）brew services start|stop|restart 软件名# 卸载软件brew uninstall 软件名# 查看软件的信息brew info 软件名# 查看安装了哪些软件brew list 软件名# 帮助brew help\n\n","tags":["mac"]},{"title":"mysql8-linux-yum","url":"/2021/03/23/mysql8-linux-yum/","content":"安装过程参照Linux系统下MySQL 8.0安装\n# 检测系统是否自带安装 MySQLrpm -qa | grep mysql# 如果有安装可以选择进行卸载# 普通删除模式# rpm -e mysql# 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除# rpm -e --nodeps mysql# 去官网下载 Yum 资源包，下载地址：https://dev.mysql.com/downloads/repo/yum/wget https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm# 安装 rpm -ivh mysql80-community-release-el7-1.noarch.rpmyum install mysql-server -y# 初始化MySQLmysqld --initialize# 加权限chown -R mysql:mysql /var/lib/mysql#启动service mysqld start# 进入日志查看密码 里面这段话为临时密码 cv出密码# A temporary password is generated for root@localhost:*****vim /var/log/mysql/mysqld.log# 进入mysql ,p后面可以直接跟上临时密码，也可以-p直接回车再输入密码mysql -u root -p临时密码\n\n修改密码#修改密码ALTER user &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;你的密码&#x27;;\n\n开启远程访问use mysql;update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;\n\n","tags":["linux","mysql","yum"]},{"title":"mysql读写分离","url":"/2020/11/11/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/","content":"安装环境2台及以上服务器：CantOS 7\n\n安装MySql# 卸载mysqlrpm -qa|grep mysql #若有可用rpm -e卸载# 查找mysql残留包，有则删除 rm -rf ，没有则忽略find / -name mysql# 安装相关依赖yum -y install make gcc-c++ cmake bison-devel ncurses-devel numactl libaio# 创建对应mysql用户groupadd mysql useradd -s /sbin/nologin -g mysql -M mysql# 下载二进制包并解压cd /usr/local/ # wget下载或者本地下载后上传-下载速度慢的话可以用国内的镜像地址下载 wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz# 解压安装包 tar -zxvf mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz# 解压后为了方便后面操作可把解压后文件名修改为mysql mv mysql-5.7.23-linux-glibc2.12-x86_64 mysql # 更改文件夹所属 chown -R mysql.mysql /usr/local/mysql# 创建mysql存储文件mkdir -p /data/mysql/&#123;data,logs,tmp&#125;# 更改文件夹所属chown -R mysql.mysql /data/mysql/# 创建配置文件vi /etc/my.cnf\n\n# 简单模板如下：[client]port            = 3306socket          = /data/mysql/tmp/mysql.sock[mysqld]user = mysqlbasedir = /usr/local/mysql        datadir = /data/mysql/data  port = 3306               socket = /data/mysql/tmp/mysql.sockpid-file  = /data/mysql/tmp/mysqld.pidtmpdir = /data/mysql/tmp    skip_name_resolve = 1symbolic-links=0max_connections = 2000group_concat_max_len = 1024000sql_mode = NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTIONlower_case_table_names = 1log_timestamps=SYSTEMcharacter-set-server = utf8interactive_timeout = 1800  wait_timeout = 1800max_allowed_packet = 32Mbinlog_cache_size = 4Msort_buffer_size = 2Mread_buffer_size = 4Mjoin_buffer_size = 4Mtmp_table_size = 96Mmax_heap_table_size = 96Mmax_length_for_sort_data = 8096#logsserver-id = 1003306log-error = /data/mysql/logs/error.logslow_query_log = 1slow_query_log_file = /data/mysql/logs/slow.loglong_query_time = 3log-bin = /data/mysql/logs/binlogbinlog_format = rowexpire_logs_days = 15log_bin_trust_function_creators = 1relay-log = /data/mysql/logs/relay-binrelay-log-recovery = 1  relay_log_purge = 1  #innodb  innodb_file_per_table = 1innodb_log_buffer_size = 16Minnodb_log_file_size = 256Minnodb_log_files_in_group = 2innodb_io_capacity = 2000innodb_io_capacity_max = 4000innodb_flush_neighbors = 0innodb_flush_method = O_DIRECTinnodb_autoinc_lock_mode = 2innodb_read_io_threads = 8innodb_write_io_threads = 8innodb_buffer_pool_size = 2G\n\n# 配置mysql.servercd /usr/local/mysql/support-filescp mysql.server /etc/init.d/mysqlvi /etc/init.d/mysql\n\n# 修改目录位置basedir=/usr/local/mysqldatadir=/data/mysql/data\n\n# 注册开机启动服务(可忽略)chkconfig --add mysqlchkconfig --list# 添加环境变量echo &quot;PATH=$PATH:/usr/local/mysql/bin  &quot; &gt;&gt; /etc/profile  source /etc/profile# 初始化mysql服务/usr/local/mysql/bin/mysqld  --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql/data# 临时密码保存在errlog中 # 获取临时密码more /data/mysql/logs/error.log |grep password# 启动mysql服务service mysql start# 使用初始密码登录mysql服务 并修改密码mysql -uroot -p\n\nalter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;root&#x27;;flush privileges;quit；#退出\n\n#重新登录mysql -uroot -p\n\n#查看数据库show databases;#进入mysql数据库修改配置use mysql;#查看用户表select host,user from user;#更新用户访问权限为远程访问update user set host=&#x27;%&#x27; where host=&#x27;localhost’;#刷新配置flush privileges;\n\n配置主从复制完成上述安装,保证mysql数据库可访问\n配置主库# 修改主库配置vi /etc/my.cnf\n\n#增加server-id 服务号保证不重复server-id=132log_bin#需要同步的数据库binlog-do-db=zgys#忽略数据库（不需要同步的数据库）binlog-ignore-db=mysql\n\n#重启mysql服务，登陆查看主机状态service mysql restartmysql -uroot -p \n\n#增加从库权限grant replication slave on *.* to &#x27;root&#x27;@&#x27;39.106.211.18&#x27; identified by &#x27;root&#x27;;show master status;#记主file 和 Position 列的值\n\n配置从库#删除auto.cnfrm -f  /data/mysql/auto.cnf# 修改主库配置vi /etc/my.cnf\n\n#增加server-idserver-id=133\n\n#重启mysql服务，登陆查看主机状态service mysql restartmysql -uroot -p \n\n#关闭从机状态stop slave;# reset slave;#设置和主机建立连接change master to master_host=&#x27;主库ip&#x27;,master_user=&#x27;主机用户名&#x27;,master_password=&#x27;主机密码&#x27;,master_log_file=&#x27;主库file&#x27;,master_log_pos=主库Position;#启动从机状态start slave#查看从机状态show slave status \\G;# Slave_IO_Running及Slave_SQL_Running进程必须正常运行，即Yes状态，否则说明同步失败,# 若失败查看mysql错误日志中具体报错详情来进行问题定位\n\n**test:**在主节点创建一个zgys的数据库，然后在该数据库加一张表，添加一条测试数据\n读写分离安装mycat\nwget http://dl.mycat.org.cn/1.6-RELEASE/Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz#解压tar -zxvf 1.6-RELEASE/Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz#移动mycat到 /usr/local/MyCat/下mv mycat /usr/local/MyCat/#修改mycat配置文件schema.xml文件和server.xmlvim /usr/local/MyCat/mycat/conf/server.xml\n\nserver.xml\n&lt;!-- 配置客户端连接Mycat的用户名、密码、逻辑数据库 --&gt;&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;    &lt;property name=&quot;schemas”&gt;zgys&lt;/property&gt;&lt;/user&gt;\n\nschema.xml\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/“&gt;    &lt;!-- 逻辑数据库配置 --&gt;    &lt;schema name=&quot;zgys&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn&quot;&gt;&lt;/schema&gt;    &lt;!-- 配置存储节点 --&gt;    &lt;dataNode name=&quot;dn&quot; dataHost=&quot;node&quot; database=&quot;zgys&quot; /&gt;    &lt;!-- 配置数据库主机 --&gt;    &lt;dataHost name=&quot;node&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot;              writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;        &lt;!--心跳检测 --&gt;        &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;        &lt;!-- 配置读、写数据库 --&gt;        &lt;writeHost host=&quot;diruipu.top&quot; url=&quot;diruipu.top:3306&quot; user=&quot;root&quot;                   password=&quot;root&quot;&gt;            &lt;readHost host=&quot;39.106.221.18&quot; url=&quot;39.106.221.18:3306&quot; user=&quot;root&quot; password=&quot;root&quot; /&gt;        &lt;/writeHost&gt;        &lt;!-- 写数据库宕机后的备份数据库 --&gt;        &lt;writeHost host=&quot;localhost&quot; url=&quot;localhost:3306&quot; user=&quot;root&quot;                   password=&quot;root&quot; /&gt;    &lt;/dataHost&gt;&lt;/mycat:schema&gt;\n\n#启动mycatmycat start\n","tags":["linux","mysql"]},{"title":"linux命令","url":"/2020/01/11/linux%E5%91%BD%E4%BB%A4/","content":"linux命令系统信息uptime   联机信息-时间$ uptime16:11  up 5 days,  2:32, 2 users, load averages: 2.16 2.23 2.26# 依次代表为：# 当前系统时间,系统运行时间,当前在线用户数,系统负荷:1分钟前、5分钟前、15分钟前\n\nw   联机信息-已登录用户$ w16:13  up 5 days,  2:34, 2 users, load averages: 2.40 2.37 2.31 #联机时间USER     TTY      FROM              LOGIN@  IDLE WHATdiruipu  console  -                四13   5days -diruipu  s002     -                13:51       - w# USER 用户名 # TTY 登录方式 # FROM 来源地址 # LOGIN@ 登录时间 # IDLE 发呆时间 # WHAT 当前任务\n\nwho 联机信息$ whoroot  console  Nov 19 13:39xxxx  ttys002  Nov 24 13:51\n\n\n\n\n参数\n作用\n\n\n\n-r\n运行级别\n\n\nwhoami  显示当前用户名$ whoamiroot\n\nlast 最近用户登录信息$ lastdiruipu   ttys002                   Tue Nov 24 13:51   still logged inroot   ttys002                   Sat Nov 21 16:19 - 16:19  (00:00)root   ttys000                   Sat Nov 21 14:38 - 14:38  (00:00)diruipu   ttys000                   Sat Nov 21 13:50 - 13:50  (00:00)\n\n\n\n\n参数\n作用\n\n\n\n-数字\n使用数字作为选项，控制显示条目\n\n\nuname 系统信息$ unameDarwin\n\n\n\n\n参数\n作用\n\n\n\n-s\n内核名称（默认选项）\n\n\n-a\n全部\n\n\n-p\nCPU 信息\n\n\n-n\n主机名\n\n\n-r\n内核发行信息（版本号）\n\n\n-v\n内核版本信息\n\n\ndate 时间$ date2020年11月24日 星期二 16时28分35秒 CST\n\n\n\n\n参数\n作用\n\n\n\n\n-u\n显示格林尼洛时间（UTC）\n\n\n\nMMDDhhmm[[CC]YY][.ss]\n设定时间，需要管理员权限。\ndate 12292359\n\n\n\nMM\n月份\n\n\n\nDD\n天数\n\n\n\nhh\n小时\n\n\n\nmm\n分钟\n\n\n\nCC\n年份前两位\n\n\n\nYY\n年份后两位\n\n\n\nss\n秒钟\n\n\n\n秒钟、年份为可选\ndate 122923592006.59\n\n\n+[%X]\n设定显示格式，默认输出格式：\ndate +%Y年%m月%d日%A%H:%M:%S%Z\n\n\n格式控制\n%n\n换行\n\n\n格式控制\n%t\n制表符\n\n\n小时\n%H\n00~23\n\n\n\n%I\n01~12\n\n\n\n%k\n0~23\n\n\n\n%l\n1~12\n\n\n\n%p\nAM\n\n\n分、秒\n%M\n分钟(00~59)\n\n\n\n%S\n秒(00..61)\n\n\n\n%T\nhh:mm:ss\n\n\n\n%r\nhh:mm:ss AM|PM\n\n\n\n%s\n从 1970年1月1日00:00:00 UTC 到目前为止的秒数\n\n\n\n%X\n%H:%M:%S\n\n\n\n%Z\n时区\n\n\n星期\n%a\nSun~Sat\n\n\n\n%A\nSunday~Saturday\n\n\n\n%w\n一周中的第几天 (0~6)\n\n\n年份\n%Y\n0000~9999\n\n\n\n%y\n00~99\n\n\n月份\n%m\n01~12\n\n\n\n%b\n\n\n\n\n%h\nJan~Dec\n\n\n\n%B\nJanuary~December\n\n\n日期\n%c\n完整日期时间\n\n\n\n%d\n01~31\n\n\n\n%j\n001~366\n\n\n\n%x\n本地格式日期\n\n\n\n%D\nmm&#x2F;dd&#x2F;yy\n\n\n一年中的第几周\n%U\n以 Sunday 为一周的第一天\n\n\n\n%W\n以 Monday 为一周的第一天\n\n\ncal  显示日历$ cal      十一月 2020日 一 二 三 四 五 六 1  2  3  4  5  6  7 8  9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 2829 30\n\n文件管理ls [路径]  显示当前目录文件列表$ lsApplications                        Library                             Postman                             logsDesktop                             Movies                              Public                              nacosDocuments                           Music                                                            Downloads                           Pictures                            \n\n\n\n\n参数\n作用\n\n\n\n–color\n不同属性以不同颜色显示（默认选项）\n\n\n-a\n全部显示\n\n\n-i\n显示 inode值\n\n\n-l\n详细信息\n\n\n-F\n显示文件类型后缀 目录/ 链接@ 可执行文件* 端口文件= 管道文件&#96;\n\n\n-A\n显示隐藏文件\n\n\n-R\n递归显示子目录文件列表\n\n\n-S\n按文件大小排序\n\n\n-t\n按修改时间排序\n\n\n-u\n按访问时间排序\n\n\n-d\n只显示目录，不递归显示目录下的文件\n\n\ncd [目录路径] | [特殊路径] 切换目录\n\n\n参数\n作用\n\n\n\n~\n$HOME 目录（默认值）\n\n\n-\n上一次目录\n\n\n..\n上一级目录\n\n\n.\n当前目录\n\n\npwd 显示当前路径$ pwd/Users/diruipu\n\nfile 文件名  显示文件类型$ file DesktopDesktop: directory\n\n\n\n\n参数\n作用\n\n\n\n-i\n显示 mime类型\n\n\ndu [路径]  计算文件或目录空间占用$ du Desktop40    Desktop\n\n\n\n参数\n作用\n\n\n\n-h\n人性化显示。自动以 G、M、K 为单位显示占用空间大小\n\n\n–max-depth&#x3D;数字\n显示目录深度\n\n\n-l\n重复计算硬链接文件大小\n\n\n-L\n计算符号链接文件大小\n\n\n-a\n显示当前目录子目录中的文件\n\n\n-c\n显示文件数\n\n\nless 文件名 浏览文件touch 目标文件 触碰触碰，在不修改文件的前提下，更改其时间属性。通常用来创建一个空文件\nmkdir 文件夹 创建文件夹\n\n\n参数\n作用\n\n\n\n-p 多级目录\n按路径创建多级目录\n\n\n-m 数字权限值\n设定权限\n\n\ncp 源文件 目标目录|文件将源文件复制为目录文件，或者将源文件复制到目标目录。多个源文件使用空格分隔\ncp 源目录 目标目录将源目录复制到目标目录中，如果复制多个源目录，需要使用 -R 选项\n\n\n\n参数\n作用\n\n\n\n-a\n相当于 -dpr 选项\n\n\n-d\n保留链接\n\n\n-f\n强制复制，覆盖目标文件\n\n\n-i\n覆盖时询问用户\n\n\n-p\n保留修改时间和访问权限\n\n\n-r -R\n递归复制（目录&#x3D;&gt;目录）\n\n\n-l\n创建链接\n\n\n-v\n显示过程\n\n\nrm 目标目录|文件 删除\n\n\n参数\n作用\n\n\n\n-r -R\n递归删除（用于删除目录）\n\n\n-f\n强制删除（无需确认，直接删除。慎用！）\n\n\n-i\n交互式删除（询问用户）\n\n\nrmdir 目标目录删除目录时，建议您使用“rm -r”命令\nmv 源文件 目标目录|文件相当于 cp 后删除源文件，也可以作为“重命名”使用。\n\n\n\n参数\n作用\n\n\n\n-f\n强制，覆盖目标文件\n\n\n-i\n覆盖时询问用户\n\n\n-v\n显示过程\n\n\nln 源文件 链接\n\n\n参数\n作用\n\n\n\n-s\n符号链接\n\n\n-f\n强制链接，覆盖目标文件\n\n\n-i\n覆盖时询问用户\n\n\n文件操作split 源文件 [目标文件名前缀]将源文件按一定规则分割成若干个目标文件。默认文件名前缀为 x\n\n\n\n参数\n作用\n\n\n\n-行数\n按行数分割文件\n\n\n-l 行数\n同上\n\n\n-b 字节\n按大小分割文件。可以使用 b、k、m 作单位，不指定单位的情况下，默认单位为 b\n\n\n-C 字节\n按大小分割文件，并尽量保持每行的完整\n\n\ncat 文件名输出文件内容。用空格分隔多个文件名\n可以将多个文件内容连接到一起输出。使用重定向合并为一个文件 cat xaa xab xac &gt; file.split\n\n\n\n参数\n作用\n\n\n\n-n\n在输出中添加行号\n\n\n-b\n在输出中添加行号，空行不编号\n\n\n-s\n将两行或以上的空行，合并为一个空行\n\n\nsort [-o 输出文件] [-t 分隔字符] [+起始字段 -结束字段] [文件]对文本内容排序\n\n\n\n参数\n作用\n\n\n\n-m\n合并文件\n\n\n-c\n检查文件是否已按规则排序\n\n\n-b\n忽略行首空格字符\n\n\n-u\n忽略内容重复行\n\n\n-f\n忽略大小写\n\n\n-l\n忽略非打印字符\n\n\n-M\n作为月份比较\n\n\n-d\n按字典顺序排序，按照字母、数字、空格、制表符排序\n\n\n-r\n逆序输出\n\n\nmore 查看文件内容查看文件内容，建议使用 less\ndiff 文件1 文件2  比较文件\n\n\n参数\n作用\n\n\n\n-u [数字]\n统一格式，数字为显示上下文行数\n\n\n–unified[&#x3D;数字]\n统一格式，数字为显示上下文行数\n\n\n-c [数字]\n上下文格式，数字为显示上下文行数\n\n\n–context[&#x3D;数字]\n上下文格式，数字为显示上下文行数\n\n\n-e\ned 命令格式\n\n\n–ed\ned 命令格式\n\n\n-f\nRCS 命令格式\n\n\npatch使用 diff -uN[r] 旧文件 新文件 &gt; 补丁文件 命令创建补丁文件。\n在待补丁文件的目录下使用 patch -p[数字] &lt;补丁文件 命令打补丁\n-p [数字] 表示忽略补丁文件中记录的目录，数字为忽略的层数。\npatch -R 已打补丁文件 补丁文件 将已打补丁文件恢复到原来的状态\ncksum [文件名]计算文件的 CRC值。不指定文件名则从标准输入设备读入数据\nmd5sum [文件名]计算文件的 md5值。不指定文件名则从标准输入设备读入数据\n\n\n\n参数\n作用\n\n\n\n-t\n以文本模式读取\n\n\n-b\n以二进制模式读取\n\n\n-c md5纪录\n校验 md5纪录 中的文件(使用 md5sum 配合重定向生成纪录文件)\n\n\n压缩解压tar [-]c|x|u|r|t[z|j][v] -f 归档文件 [待打包文件]将多个文件打包为一个归档文件，可以在打包的同时进行压缩。支持的格式为 tar（归档）、gz（压缩）、bz2（压缩率更高，比较耗时）\n\n\n\n参数\n作用\n\n\n\n\n操作选项\n-c\n创建\n\n\n\n-x\n解包\n\n\n\n-u\n更新\n\n\n\n-r\n添加\n\n\n\n-t\n查看\n\n\n\n-d\n比较压缩包内文件和文件\n\n\n\n-A\n将 tar 文件添加到归档文件中\n\n\n格式选项\n-z\n使用 gz 压缩格式\n\n\n\n-j\n使用 bz2 压缩格式\n\n\n其它\n-v\n显示过程\n\n\n\n-f 文件名\n归档文件的文件名，使用 - 代表标准输入&#x2F;输出\n\n\n\n-C 解压路径\n将压缩包中的文件解压到指定目录\n\n\n\n–exclude&#x3D;文件\n排除文件\n\n\n\n-P\n使用绝对路径压缩时，保留根目录“&#x2F;”\n\n\n\n-W\n校验\n\n\n\n-p\n还原文件权限\n\n\n\n-w\n询问用户\n\n\n\n–totals\n统计\n\n\n\n-T 文件列表\n处理文件列表中的文件\n\n\n\n-X 文件列表\n排除文件列表中的文件\n\n\n7z|7za 子命令 [选项] 压缩包 [文件]\n\n\n参数\n作用\n\n\n\n\n子命令\na\n添加\n\n\n\nd\n删除\n\n\n\ne\n解压\n\n\n\nx\n带路径解压\n\n\n\nl\n列表查看\n\n\n\nt\n测试\n\n\n\nu\n更新\n\n\n选项\n-m 压缩方式\n\n\n\n\n-m0&#x3D;压缩算法\n默认使用 lzma\n\n\n\n-mx&#x3D;数字\n1~9 压缩级别\n\n\n\n-mfb&#x3D;64\nnumber of fast bytes for LZMA &#x3D; 64\n\n\n\n-md&#x3D;字典大小\n设置字典大小，例如 -md&#x3D;32m\n\n\n\n-ms&#x3D;on|off\n是否固实压缩\n\n\n\n-o输出目录\n设置输出目录\n\n\n\n-p密码\n使用密码\n\n\n\n-r数字\n递归，使用数字定义递归子目录的深度\n\n\n\n-sfx[模块名称]\n使用自解压模块\n\n\n\n-si\n从标准输入设备读入数据\n\n\n\n-so\n将数据写入标准输出设备\n\n\n\n-y\n所有询问均回答 Yes\n\n\n\n-w路径\n设置工作目录\n\n\n搜索whereis 程序名称查找软件的安装路径\n\n\n\n参数\n作用\n\n\n\n-b\n只查找二进制文件\n\n\n-m\n只查找帮助文件\n\n\n-s\n只查找源代码\n\n\n-u\n排除指定类型文件\n\n\n-f\n只显示文件名\n\n\n-B 目录\n在指定目录下查找二进制文件\n\n\n-M 目录\n在指定目录下查找帮助文件\n\n\n-S 目录\n在指定目录下查找源代码\n\n\nlocate 文件名称在文件索引数据库中搜索文件\nupdatedb 更新文件索引数据库\n\n\n\n参数\n作用\n\n\n\n-d 数据库路径\n搜索指定数据库\n\n\nfind [路径] 表达式查找文件\n\n\n\n参数\n作用\n\n\n\n-name 表达式\n根据文件名查找文件\n\n\n-iname 表达式\n根据文件名查找文件，忽略大小写\n\n\n-path 表达式\n根据路径查找文件\n\n\n-ipath 表达式\n根据路径查找文件，忽略大小写\n\n\n-amin 分钟\n过去N分钟内访问过的文件\n\n\n-atime 天数\n过去N天内访问过的文件\n\n\n-cmin 分钟\n过去N分钟内修改过的文件\n\n\n-ctime 天数\n过去N天内修改过的文件\n\n\n-anewer 参照文件\n比参照文件更晚被读取过的文件\n\n\n-cnewer 参照文件\n比参照文件更晚被修改过的文件\n\n\n-size 大小\n根据文件大小查找文件，单位 b c w k M G\n\n\n-type 文件类型\n根据文件类型查找文件。b 块设备 c 字符设备 d 目录 p 管道文件 f 普通文件 l 链接 s 端口文件\n\n\n-user 用户名\n按归属用户查找文件\n\n\n-uid 用户编号\n按用户编号查找文件\n\n\n-group 群组名\n按归属群组查找文件\n\n\n-gid 群组编号\n按群组编号查找文件\n\n\n-empty\n查找空文件\n\n\ngrep 字符串|正则表达式 文件名|标准输入在文件中搜索内容\n权限管理chmod 权限表达式 文件|目录更改文件的权限。权限的表达式可以使用 3位8进制数字 表示，或者使用 augo +-&#x3D; rxw-s 来表示\na 所有用户 u 归属用户 g 归属群组 o 其它用户&#x3D; 具有权限 + 增加权限 - 去除权限r 可读权限 w 可写权限 x 可执行权限 \n\n\n\n参数\n作用\n\n\n\n-R\n递归\n\n\n-v\n显示过程\n\n\n-c\n类似“-v”，仅显示更改部分\n\n\n–reference&#x3D;参照文件或目录\n以指定文件为参照更改权限\n\n\n示例：\nchmod -R a+x pathchmod -Rv 755 path    \n\nchown 归属用户[:归属群组] 文件|目录更改文件的归属用户。可以使用用户名或者用户编号\n\n\n\n参数\n作用\n\n\n\n-R\n递归\n\n\n-v\n显示过程\n\n\n-c\n类似“-v”，仅显示更改部分\n\n\n–reference&#x3D;参照文件或目录\n以指定文件为参照更改权限\n\n\n示例：\nchown user:admin pathchown -R user.admin pathchown user path    \n\nchgrp 归属群组 文件|目录更改文件的归属群组。可以使用群组名或者群组编号,选项同上\nSUID、SGID、Sticky bit例如：用户自行设定密码。出于安全方面的考虑， /etc/shadow 只能由 root用户 直接修改。\n-rw------- root root /etc/shadow    \n\n这个时候，可以为程序 &#x2F;usr&#x2F;bin&#x2F;passwd 设置 SUID，当普通用户执行“passwd”命令时，便能够以该程序归属用户 root 的身份修改 &#x2F;etc&#x2F;shadow 文件。而“passwd”程序自身带有身份验证机制，不能通过验证时拒绝执行，从而保证了安全。\nls -l /usr/bin/passwd-r-s--x--x root root /usr/bin/passwd    \n\n我们发现，归属用户的可执行权限位使用 s ，表示 SUID。同样，归属群组的可执行权限位使用 s ，表示 SGID。任何用户或群组都拥有 “其它用户” 的权限，所以不需要以 其它用户 身份执行文件，其它用户的可执行权限位便不会出现 s 。该权限位可能出现的属性为 t ，也就是粘着位 Sticky bit。\nls -ld /tmpdrwxrwxrwt root root /tmp    \n\n粘着位表示任何用户都可能具有写权限，但只有该归属用户或 root用户 才能够删除\nSUID、SGID、Sticky bit 也可以像权限一样，使用一个八进制数表示，如下：\n\n\n\n4\nSUID\n\n\n\n2\nSGID\n\n\n1\nSticky bit\n\n\nlsattr [路径]查看文件的特殊属性\n\n\n\n参数\n作用\n\n\n\n-a\n全部显示\n\n\n-d\n只显示目录\n\n\n-R\n递归\n\n\n特殊属性包括：\n\n\n\na\n仅供附加用途\n\n\n\nb\n不更新最后存取时间\n\n\nc\n压缩后存放\n\n\nd\n排除在转储操作之外\n\n\ni\n不得任意更动文件或目录\n\n\ns\n保密性删除文件或目录\n\n\nS\n即时更新文件或目录\n\n\nu\n预防意外删除\n\n\nchattr +|-|&#x3D;属性 路径更改文件特殊属性\n\n\n\n参数\n作用\n\n\n\n-R\n递归\n\n\n-V\n显示过程\n\n\n用户管理root 用户为根用户,也就是系统管理员,拥有全部权限\n一个用户只能拥有一个 群组编号 ，但是还可以归属于其它附加群组\n用户管理的重要配置文件：\n\n\n\n&#x2F;etc&#x2F;passwd\n用户名 密码位 用户编号 归属群组编号 姓名 $HOME目录 登录Shell\n\n\n\n&#x2F;etc&#x2F;shadow\n用户名 已加密密码 密码改动信息 密码策略\n\n\n&#x2F;etc&#x2F;group\n群组名 密码位 群组编号 组内用户\n\n\n&#x2F;etc&#x2F;gshadow\n群组密码相关文件\n\n\n&#x2F;etc&#x2F;sudoers\n用户名 权限定义 权限\n\n\n\n请使用“visudo”命令修改/etc/sudoers，而不要直接编辑\n可以使用 pwconv 命令创建影子密码，将 /etc/passwd 文件中的密码转换到 /etc/shadow 文件\n\nsu [用户名]切换到其它用户，默认切换到 root用户。提示密码为目标用户密码\n\n\n\n参数\n作用\n\n\n\n-f\n快速切换，忽略配置文件\n\n\n- | -l\n重新登录\n\n\n-m |-p\n不更改环境变量\n\n\n-c 命令\n切换后执行命令，并退出切换\n\n\nsudo 命令以其它用户的身份执行命令，默认以 root 的身份执行。提示密码为当前用户密码\n\n\n\n参数\n作用\n\n\n\n-s\n切换为 root shell\n\n\n-i\n切换为 root shell，并初始化\n\n\n-u 用户名|用户编号\n执行命令的身份\n\n\n-l\n显示自己的权限\n\n\npasswd [用户名]设定用户密码\n\n\n\n参数\n作用\n\n\n\n-d\n清除密码\n\n\n-l\n锁定账户\n\n\n-e\n使密码过期，在下次登录时更改密码\n\n\n-S\n显示密码认证信息\n\n\n-x 天数\n密码过期，最大使用时间\n\n\n-n 天数\n冻结密码，最小使用时间\n\n\n-s\n更改 登录Shell\n\n\n-f\n更改用户信息\n\n\n示例：\n$passwdChanging password for user(current) UNIX password:      #原密码Enter new UNIX password:      #新密码Retype new UNIX password:     #确认新密码    \n\ngpasswd 群组名更改群组\n\n\n\n参数\n作用\n\n\n\n-d 用户名\n将用户从群组中删除\n\n\n-a 用户名\n将用户加入群组\n\n\n-r\n删除密码\n\n\n-A 用户名\n将用户设置为群组管理员(群组管理员或 root 才可以使用 gpasswd 命令）\n\n\n-M 用户1,用户2……\n设置群组成员\n\n\nchsh -s Shell [用户名]更改登录 Shell\nusermod 用户名修改用户账号\n\n\n\n参数\n作用\n\n\n\n-d 目录\n设定 $HOME 目录\n\n\n-m\n设定 $HOME 目录时自动建立该目录\n\n\n-s Shell\n修改用户 登录Shell\n\n\n-l 新登录名\n修改为新登录名\n\n\n-u 用户编号\n修改用户编号\n\n\ng 群组名\n修改用户归属群组\n\n\n-G 群组名\n修改用户归属辅组\n\n\n-L\n锁定帐户\n\n\n-U\n解除锁定\n\n\n-e 过期时间\n设定用户账号过期时间\n\n\n-f 缓冲天数\n设定密码过期后多长时间关闭账号\n\n\n-c 字符串\n修改用户备注\n\n\nuseradd 用户名新建用户\n\n新建用户规则保存于 /etc/login.defs 文件中\n新建用户默认文件保存于 /etc/skel/ 目录中。新建用户时，系统自动拷贝此目录下的文件至新建用户的 $HOME 目录\n\n\n\n\n参数\n作用\n\n\n\n-d 目录\n设定 $HOME 目录\n\n\n-m\n自动建立 $HOME 目录\n\n\n-M\n不自动建立 $HOME 目录\n\n\n-s Shell\n设定用户 登录Shell\n\n\n-u 用户编号\n设定用户编号\n\n\n-g 群组名\n设定用户归属群组\n\n\n-G 群组名\n设定用户归属附加群组\n\n\n-n\n不建立以用户名为名称的群组\n\n\n-e 过期时间\n设定用户账号过期时间\n\n\n-f 缓冲天数\n设定密码过期后多长时间关闭账号\n\n\n-c 字符串\n设定用户备注\n\n\n-D [表达式]\n更改预设值 （预设值保存于 &#x2F;etc&#x2F;default&#x2F;useradd 文件中）\n\n\nuserdel 用户名删除用户\n\n\n\n参数\n作用\n\n\n\n-r\n删除用户相关文件和目录\n\n\nid [用户名]显示用户 用户编号 群组编号 归属附加群组\n进程管理进程一般分为批处理进程、交互进程和守护进程三类。\n守护进程总是活跃，在系统启动时通过脚本自动启动，或由 root 启动，通常在后台运行。\n一个进程可以拥有子进程。当父进程终止时，它的子进程也随之终止；而子进程终止时，父进程通常可以继续运行。\ninit 进程为根进程，所有进程都是它的子进程\nps显示进程信息，选项可省略 “**-**”\n\n\n\n参数\n作用\n\n\n\naux\n以 BSD风格 显示进程 常用\n\n\n-efH\n以 SystemV风格 显示进程\n\n\n-e | -A\n显示所有进程\n\n\na\n显示终端上所有用户的进程\n\n\nx\n显示无终端进程\n\n\nu\n显示详细信息\n\n\nf\n树状显示\n\n\nw\n完整显示信息\n\n\nl\n显示长列表\n\n\n输出字段\n\n\n\n参数\n作用\n\n\n\n\nUSER\n进程所有者\n\n\n\nPID\n进程编号\n\n\n\nPPID\n父进程编号\n\n\n\n%CPU\nCPU 占用率\n\n\n\n%MEM\n内存占用率\n\n\n\nNI\n进程优先级。数值越大，占用 CPU 时间越少\n\n\n\nVSZ\n进程虚拟大小\n\n\n\nRSS\n页面文件占用\n\n\n\nTTY\n终端编号\n\n\n\nSTAT\n进程状态\n\n\n\n\nD\n不可中断\n\n\n\nR\n正在运行，或在队列中的进程\n\n\n\nS\n处于休眠状态\n\n\n\nT\n停止或被追踪\n\n\n\nZ\n僵尸进程\n\n\n\nX\n死掉的进程\n\n\n\n&lt;\n高优先级\n\n\n\nN\n低优先级\n\n\n\nL\n有些页被锁进内存\n\n\n\ns\n包含子进程\n\n\n\n+\n位于后台的进程组\n\n\n\nl\n多线程，克隆线程\n\n\npstree [ 进程编号 | 用户 ]树状显示进程信息。可选择显示某用户的进程或从某进程编号开始的进程\n\n\n\n参数\n作用\n\n\n\n-a\n显示完整命令及选项\n\n\n-c\n完全显示重复进程\n\n\n-p\n显示进程编号，隐含-c\n\n\n-n\n按进程编号排列进程\n\n\n-u\n显示进程所有者\n\n\n-h\n\n\n\n-H 进程编号\n高亮显示进程编号指定的进程及其祖先\n\n\npgrep 进程名显示进程编号\n\n\n\n参数\n作用\n\n\n\n-l\n显示进程名和进程编号\n\n\n-o\n进程起始编号\n\n\n-n\n进程终止编号\n\n\nkill [信号代码] 进程编号根据进程编号向进程发送信号，常用来结束进程，默认信号为 -9\n\n\n\n参数\n作用\n\n\n\n-l [信号代码]\n显示、翻译信号代码\n\n\n-9 | -KILL\n发送 kill 信号,退出\n\n\n-6 | -ABRT\n发送 abort 信号,退出\n\n\n-15 | -TERM\n发送 Termination 信号\n\n\n-1 | -HUP\n挂起\n\n\n-2 | -INT\n从键盘中断，相当于 Ctrl+c\n\n\n-3 | -QUIT\n从键盘退出，相当于 Ctrl+d\n\n\n-4 | -ILL\n非法指令\n\n\n-11 | -SEGV\n内存错误\n\n\n-13 | -PIPE\n破坏管道\n\n\n-14 | -ALRM\n\n\n\n-STOP\n停止进程，但不结束\n\n\n-CONT\n继续运行已停止的进程\n\n\n-9 | -1\n结束当前用户的所有进程\n\n\npkill [信号代码] 进程名称结束进程族。如果结束单个进程，请用 kill\nxkill在图形界面中点杀进程。执行此命令后，鼠标指针变为骷髅图案（一定看过《加勒比海盗》吧）。在窗口中点击左键杀死进程，右键取消\ntop动态、交互式进程管理器\n\n\n\n功能\n参数\n具体作用\n\n\n\n启动选项\n-b\n\n\n\n\n-c\n显示进程启动状态，包括选项、参数、操作对象等；而不只是进程名\n\n\n\n-d 秒\n刷新频率。 -d 5，表示5秒刷新一次\n\n\n\n-n 次\n刷新次数，然后退出。 -n 5，表示刷新5次后退出\n\n\n\n-i\n禁止显示空闲进程或僵尸进程\n\n\n\n-p 进程编号\n仅监视指定进程的编号\n\n\n\n-s\n安全模式运行，禁用一些交互指令\n\n\n\n-S\n累积模式，输出每个进程的总的 CPU 时间，包括已死的子进程\n\n\n交互命令\nspace\n立即刷新\n\n\n\nk\n交互式杀死进程，提示输入进程编号 （默认发送信号15）\n\n\n\nr\n设定 renice，提示输入进程编号和 renice值\n\n\n\ns\n改变两次刷新时间间隔，以秒为单位\n\n\n\nn\n设定显示进程数， 0 为不作限制\n\n\n\ni\n隐藏空闲进程和僵尸进程\n\n\n\nS\n切换到累积时间模式\n\n\n\nl\n开关，在顶部显示 uptime 信息\n\n\n\nt\n开关，在顶部显示 进程和 CPU 状态\n\n\n\nm\n开关，在顶部显示 free 信息\n\n\n\nc\n显示方式切换： 进程名&#x2F;进程启动状态\n\n\n\nA\n按进程启动顺序进行排序。由新到旧\n\n\n\nM\n按内存占用排序。由大到小\n\n\n\nN\n以进程编号排序。由大到小\n\n\n\nP\n按 CPU 占用排序。由大到小\n\n\n\nT\n按时间／累积时间排序\n\n\n\nf|F\n设定显示字段。设定完成后空格退出\n\n\n\no|O\n设定显示字段的排序。大写向前移动，小写向后移动，空格退出\n\n\n\nh|?\n显示有关安全模式和累积模式的帮助信息\n\n\n\nW\n把当前的配置写到 ~&#x2F;.toprc 中\n\n\nrenice 优先级 进程重新设定进程优先级（通常无此必要）\n\n\n\n类别\n参数\n作用\n\n\n\n优先级表达式\n+|-|&#x3D; nice值\n\n\n\n\nnice 取值范围\n-20~19\n\n\n进程表达式\n-p 进程编号\n通过进程编号进行设定\n\n\n\n-g 进程群组编号\n通过进程群组编号\n\n\n\n-u 用户编号\n\n\n\nnohup 命令 [选项]将任务提交到后台，输出附加到 ~/nohup.out 文件。即便用户退出登录，提交的命令仍继续执行。\n命令 &amp;背景执行此命令，如果用户退出登录，则命令停止执行\n命令1 ; 命令2 ; ……命令队列，从左向右，依次执行以 ; 分隔的命令\n命令1 &amp;&amp; 命令2 &amp;&amp; ……命令队列，从左向右，依次执行以 &amp;&amp; 分隔的命令。前一个命令执行成功，后一个命令才能执行\nCtrl+z挂起当前任务\njobs显示背景任务\n\n\n\n参数\n作用\n\n\n\n-l\n显示完整信息\n\n\nbg [任务编号]将挂起的任务背景执行\nfg [任务编号]将背景任务调到前台执行\n磁盘和内存管理Linux 中，设备用/dev/目录下的文件表示。例如\n/dev/hda1 第一块硬盘的第一主分区/dev/hdb5 第二块硬盘的第一逻辑分区/dev/sda4 第一块 SATA 硬盘的第四主分区，或者扩展分区/dev/null 黑洞设备    \n\nmount 设备文件 [挂载路径]挂载文件系统\n\n\n\n\n\n\n\n\n\n-t\n指定文件系统的类型\n通常不必指定，mount 自动检测\n\n\n常见类型\nreiserfs\nReiserFS 3.6版\n\n\n\nxfs\nSGI 技术\n\n\n\njfs\nIBM 技术\n\n\n\next3\nLinux 传统文件系统\n\n\n\nvfat\nfat fat32\n\n\n\next2\nLinux 传统文件系统，不带日志\n\n\n\nntfs\nWINNT\n\n\n\niso9660\n光盘\n\n\n\nsmbfs\nWindows 文件共享\n\n\n-o [选项1] [选项2] …..\n\n\n\n\n选项\nloop\n环设备。光盘、ISO 映像文件等，通常用于挂载映像文件（而不是设备文件）\n\n\n\nbind\n绑定。将一个目录（而不是设备文件）挂载到另一个目录\n\n\n\nro | rw\n只读 readonly；可读写 read-write\n\n\n\nsync | async\n同步模式|异步模式。决定修改是否立即写入文件系统\n\n\n\natime | noattime\n读取时是否修改访问时间。对于写入敏感设备，例如闪存、软盘，建议使用 noatime\n\n\n\nauto | noauto\n自动挂载模式\n\n\n\nexec | noexec\n是否允许执行\n\n\n\ndefaults\n使用预设的选项 rw, suid, dev, exec, auto, nouser, async\n\n\n\niocharset&#x3D;UTF-8\n指定字符集，可简写为 utf8\n\n\n\ncodepage&#x3D;936\n指定代码页，可简写为 cp936 西文系统代码页为 437\n\n\n\numask&#x3D;权限掩码\n设定权限掩码\n\n\n\nuid&#x3D;用户编号\n设定归属用户\n\n\n\ngid&#x3D;群组编号\n设定归属群组\n\n\n\nremount\n以不同选项重新挂载\n\n\n\n-L 卷标\n挂载带有特殊卷标的分区\n\n\n权限掩码&#x3D;777-目标权限（三位） | 7777-目标权限（四位）\n假如权限掩码为 022 ，则目标权限为 755 rwxr-xr-x\n可以使用 umask 命令设置权限掩码\n\n挂载 NTFS 分区时请使用 utf8 选项；挂载 FAT 分区时请使用 iocharset&#x3D;utf8,codepage&#x3D;936 选项，以避免乱码\n\nmount -a\n挂载 /etc/fstab 文件中定义的所有设备。示例：\nsudo mount -t iso9660 -o loop /dev/cdrom0 /media/cdromsudo mount -t vfat -o remount iocharset=utf8,codepage=936  /dev/hda5 /media/hda5  \n\numount 设备文件 | 挂载路径卸载已挂载文件系统\ndf查看已挂载文件系统的磁盘空间占用\n\n\n\n命令\n作用\n\n\n\n-a\n显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc 文件系统\n\n\n-T\n显示文件系统类型\n\n\n-k\n以 k 字节为单位显示\n\n\n-i\n显示 i节点 信息，而不是磁盘块\n\n\n-t 文件系统类型\n显示指定类型的文件系统的磁盘空间使用情况\n\n\n-x 文件系统类型\n列出排除指定类型文件系统的磁盘空间使用情况（与 t 选项相反）\n\n\n-l\n只显示本地文件系统\n\n\nfree查看内存、缓冲区、交换空间的占用\n\n\n\n命令\n作用\n\n\n\n-b\n以字节为单位显示数值\n\n\n-k\n以千字节为单位显示数值\n\n\n-m\n以兆字节为单位显示数值\n\n\n-g\n以吉字节为单位显示数值\n\n\n-l\n显示内存占用峰值\n\n\n-o\n不显示缓冲区占用\n\n\n-t\n统计结果\n\n\n-s 秒\n刷新频率\n\n\nsync同步文件系统。将缓冲区中的数据写入文件系统\nfdisk 磁盘设备文件分区表修改工具(磁盘设备文件应为整块磁盘，而不是磁盘中的分区。例如 /dev/sda ，而不是 /dev/sda1)\nfdisk -l 查看所有磁盘分区信息\n\n\n\n命令\n作用\n\n\n\nm\n使用帮助\n\n\nl\n查看已知文件系统类型\n\n\np\n显示分区信息\n\n\nn\n新建分区 （p:主分区 l:扩展分区 参见 “分区概念”一节 )\n\n\nd\n删除分区\n\n\nt\n改变分区类型\n\n\nw\n将改动写入分区表\n\n\nq\n放弃改动并退出\n\n\ncfdisk更加友善的分区表修改工具\nmkfs.文件系统类型 分区设备文件将分区格式化为文件系统。示例：\nsudo mkfs.reiserfs /dev/hda1sudo mkfs.xfs /dev/sda1    \n\nhdparm 磁盘设备文件设置硬盘参数\n\n\n\n命令\n作用\n\n\n\n-d 0|1\nDMA 模式开关\n\n\n-a 0|1\n预读模式开关\n\n\n-t\n性能测试\n\n\n-T\n缓存性能测试\n\n\n-c 0|1|3\n32位传输模式开关\n\n\n-g\n显示柱面，扇区等信息\n\n\n-i|-I\n显示磁盘信息\n\n\n硬件管理lspci查看 PCI 总线连接的设备(实际上也可以查看 ISA、AGP、USB 等总线信息)\n\n\n\n参数\n作用\n\n\n\n－v\n显示详细信息\n\n\n－vv\n\n\n\n－vvv\n\n\n\n－k\n同时显示使用的驱动和加载的模块\n\n\n－n\n显示设备 ID号\n\n\n－b\n显示 PCI、ISA 扩展槽地址和中断\n\n\n－t\n显示总线树结构\n\n\n-F 文件\n从指定文件读信息\n\n\n－m\n以便于机器处理的格式输出所有硬件信息\n\n\n-mm\n\n\n\nlsusb查看 USB 接口连接的设备\nlsmod查看已加载模块。/lib/modules/uname -r 目录下为所有可用模块\nmodprobe 模块名称启用模块\n\n\n\n参数\n作用\n\n\n\n-a\n加载所有匹配模块\n\n\n-c\n显示当前使用的配置\n\n\n-d\n显示调试信息\n\n\n-k\n将指定模块设置为”自动清除”模式\n\n\n-l\n显示所有匹配模块\n\n\n-n\n模拟执行\n\n\n-q\n不显示错误信息\n\n\n-r\n删除使用命令加载的模块;对非命令加载的模块设置”自动清除”模式\n\n\n-s\n将结果记录到系统记录中\n\n\n-t\n指定模块类型\n\n\n-v\n显示详细信息\n\n\n-C\n指定配置文件.默认使用/etc/modules.conf文件为配置文件\n\n\n其它echo 字符串回显。较复杂的字符串，可以使用 &quot; 括起来。\n\n\n\n类型\n参数\n作用\n\n\n\n选项\n-n\n输出内容不换行\n\n\n\n-E\n不解析脱字符\n\n\n\n-e\n解析脱字符\n\n\n控制字符\n\\\n反斜线\n\n\n\n\\a\n警告\n\n\n\n\\b\n退格\n\n\n\n\\n\n换行\n\n\n\n\\r\n回车\n\n\n\n\\t\n水平制表符\n\n\nclear清空屏幕\nalias 输入内容&#x3D;实际内容别名，为命令指定一个别名，以简化输入。例如：\nalias ls=&#x27;ls -AF --color=auto&#x27;    \n\n可以将您的定义保存在 ~/.bashrc 文件中\nexport 变量名将变量导出为环境变量，常写变量赋值一同使用，例如：\nexport PATH=&quot;$PATH:xxx&quot;    \n\nshutdown关闭计算机，向根进程 init 发送信号，更改 runlevel 为 0 (halt)\n\n\n\n参数\n作用\n\n\n\n-h\n关闭电源\n\n\n-r\n重启\n\n\n-n\n强行关机，不向 init进程 发送信号\n\n\n-k\n模拟关机，向登录者发送关机警告\n\n\n-t 秒\nN秒后关机\n\n\ntime 时间\n定时关机\n\n\n-c [说明信息]\n取消关机\n\n\n-f\n重启时忽略检测文件系统\n\n\n-F\n重启时强制检测文件系统\n\n\nhalt关闭计算机。 调用 shutdown -h ，结束系统进程，同步文件系统，停止内核。\n\n\n\n参数\n作用\n\n\n\n-n\n不同步文件系统\n\n\n-w\n模拟关机，写 /var/log/wtmp 纪录\n\n\n-f\n不调用 shutdown ,强行关机\n\n\n-p\n默认选项，关机时调用 poweroff\n\n\n-i\n关机前断开网络\n\n\nreboot重新启动计算机。选项与 halt 相似\ninit 数字更改运行级别\n\n\n\n参数\n作用\n\n\n\n0\n关机\n\n\n1\n单用户模式\n\n\n6\n重启\n\n\nchroot 路径更改根目录，重新定义会话的运行环境。（通常用在多系统环境下使用）\n","tags":["linux"]},{"title":"nginx相关配置","url":"/2020/04/11/nginx%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","content":"nginx安装步骤(linux)#下载压缩包wget http://nginx.org/download/nginx-1.18.0.tar.gz# 安装依赖yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel# 解压缩tar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0/# 执行配置./configure# 编译安装(默认安装在/usr/local/nginx)makemake install\n\n常用命令#检查配置文件/usr/local/nginx/sbin/nginx -t#停止/usr/local/nginx/sbin/nginx -s stop/quit#重启/usr/local/nginx/sbin/nginx -s reload#启动/usr/local/nginx/sbin/nginx\n\n配置https#以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。server &#123;         listen 443 ssl; #配置HTTPS的默认访问端口号为443。此处如果未配置HTTPS的默认访问端口，可能会造成Nginx无法启动。Nginx 1.15.0以上版本请使用listen 443 ssl代替listen 443和ssl on。         server_name diruipu.top;#将www.certificatestests.com修改为您证书绑定的域名，例如：www.example.com。如果您购买的是通配符域名证书，要修&gt;改为通配符域名，例如：*.aliyun.com。         root html;         index index.html index.htm;         ssl_certificate cert/diruipu.top.pem;  #将domain name.pem替换成您证书的文件名称。         ssl_certificate_key cert/diruipu.top.key; #将domain name.key替换成您证书的密钥文件名称。         ssl_session_timeout 5m;         ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;#使用此加密套件。         ssl_protocols TLSv1 TLSv1.1 TLSv1.2;#使用该协议进行配置。         ssl_prefer_server_ciphers on;         location / &#123;         root html; #站点目录。         index index.html index.htm;                    &#125;      &#125;\n\n开启http自动转为https\n\\#在http 的server里面配置这句话rewrite ^(.*)$ https://$host$1 permanent;\\#将所有HTTP请求通过rewrite重定向到HTTPS。\n\n其他配置太多了直接搜索  谷歌｜百度｜Bing\n","tags":["linux","nginx"]},{"title":"md语法练习","url":"/2019/02/22/test-sit/","content":"标题\n内容\n\n标题2console.log(&#x27;HelloWorld&#x27;);\n\n标题3\n无序列表1\n无序列表2\n无序列表3\n\n标题4加粗\n倾斜\n标题5\n\n\n列1\n列2\n列3\n\n\n\n1\n1\n1\n\n\n2\n2\n2\n\n\n3\n3\n3\n\n\n","tags":["md"]},{"title":"vim编辑器","url":"/2020/03/28/vim%E7%BC%96%E8%BE%91%E5%99%A8/","content":"命令使用 Vim 编辑文件:\nvi [文件名]vim [文件名]\n\n教学模式:\nvimtutor [语言]\n\nvim 教程，相当于使用Vim编辑器以只读模式打开教程文件。您无论对这个文件作了什么，都会在退出后恢复原来的样貌。与只读模式的区别在于，它不会没有眼色的提醒您，现在的状态为只读模式。您可以使用它作一些练习\n您可以指定教程文件的语言，如果使用本地语言(ZH_cn)出现乱码，您可以尝试使用英语\nvimtutor en\n\n使用 Vim 比较文件区别\nvimdiff [文件1] [文件2] [其它文件]……  \n\n配置文件Vim 的全局配置文件为 /etc/vim/vimrc ，用户配置文件为 ~/.vimrc ， &quot; 起始的行为注释行。我们提供的配置项，直接加入配置文件就可以了\n例如：可以先对 Vim 进行一些简单的配置\n&quot;运行在非兼容(VI)模式下(命令模式下 TAB 补全)set nocompatible&quot;设定文件编码set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936&quot;开启语法加亮syntax on&quot;配色风格colorscheme pablo&quot;简洁启动模式set shortmess=atI&quot;设定 GUI 选项&quot;set guioptions=gmrLtT  m:菜单 T:工具栏set guioptions=gmrLt&quot;命令行高度set cmdheight=1&quot;设定行距 ( GUI 界面中生效 )set linespace=4&quot;显示标尺set ruler&quot;自动折行&quot;set nowrapset wrap&quot;按完整单词折行set nolinebreak&quot;set linebreak&quot;行宽（输入时自动插入换行符）&quot;set textwidth=80set textwidth=0&quot;允许在 虚空间 内操作 （虚空间:不包含任何文本的空间。如换行符之后）&quot;set virtualedit=all&quot;禁止在 虚空间 内操作set virtualedit=&quot;设定 Tab 键缩进的空格数set tabstop=4&quot;设定编辑器将多少空格视为一个缩进set shiftwidth=4&quot;将缩进转换为空格&quot;set expandtab&quot;设定自动缩进(新行与前一行缩进相同)set autoindent&quot;set noautoindent&quot;插入模式下，“←”如何删除光标前的字符：行首空白、换行符、插入点之前的字符set backspace=indent,eol,start&quot;命令行历史纪录set history=500&quot;禁用增量搜索set incsearch&quot;set noincsearch&quot;搜索时忽略大小写set ignorecase&quot;set noignorecase&quot;高亮显示搜索结果set hlsearch&quot;设定折叠方式&quot;set foldmethod=manual&quot;以下字符将被视为单词的一部分 (ASCII)：&quot;set iskeyword+=33-47,58-64,91-96,123-128\n\n模式行也可以通过“模式行”将配置选项嵌入在普通文件中。打开此文件时，优先使用模式行中的配置：\n# vim: filetype=sh foldmethod=marker autoindent expandtab shiftwidth=4模式行可以写在任意位置但为了不影响文件功能，模式行通常写在注释中模式行以 vim: 起始，前面至少要有一个空白字符（空格、换行符等）模式行中的设置项以空格分隔……\n\n这种形式的缺点在于，不能在设置项后添加其它文本。如果有相关需要，可以使用另一种模式行：\n&lt;!-- vim:set filetype=html: 这里可以任意添加文本 --&gt;    \n\n模式介绍Vim 常见的模式有： 普通模式 、 插入模式 、 命令模式 ，另外我们也会经常用到 可视模式 。\n\nVim 启动时进入 *普通模式* ；或者在其它模式下，按下 Esc 键，便可以回到普通模式。\n使用 vimtutor en 命令进入教程，现在是普通模式。随便按几下 j 、 k 、 l 、 h 键，您会发现光标的位置发生改变。\n按下 i 键，编辑器底部出现了 – 插入 – 或者 – insert – ，您进入了插入模式。随便按几下 j 、 k 、 l 、 h ，您会发现相应的字符出现在编辑区，现在还可以通过方向键来移动光标。可能您觉得使用方向键移动光标不是什么问题，但是习惯了 Vim 后，您反而会认为方向键太麻烦了，简直不能容忍！好了，现在按下 Esc 键回到普通模式，我们又可以使用 j 、 k 、 l 、 h 来移动光标了。\n在普通模式下，按下 : 键（也就是 Shift+; ），在编辑器底部出现了一个 : ，您进入了命令模式。在 : 后输入一个命令 new ，回车后，编辑器被分割为上下两栏。为了方便起见，我们在命令前加一个 : 来表示命令模式下输入的命令，像这样\n:vnew\n\n命令能够以一些规则简化，上面的命令也可以写为这种形式\n:vne\n\n现在您的编辑区一定弄的四分五裂，您可以使用命令“**:quit**”来关闭当前栏，直接用简写就可以了\n:q\n\n这个命令是退出编辑器，如果编辑区被分成多栏，则是退出当前栏。\n执行完一个命令（按下回车后），编辑器会自动回到普通模式。如果想不执行当前命令，直接回到普通模式，您可以按下 Esc键。\n按下 v 键，您进入了可视模式，可以使用 j 、 k 、 l 、 h 移动光标，高亮选取文本 。\n事实上，可视模式相当于高亮选取文本后的普通模式。\n可视模式具有多种模式，以行为单位进行选取的可视行模式，使用 V 键进入（也就是 Shift+v ）；和以块为单位进行选取的可视块模式，使用 Ctrl+v 键进入。\n\n模式切换|当前模式|目标模式|操作|\n\n\n\n其它模式\n普通模式\nEsc\n\n\n\n\n普通模式\n插入模式\ni\n在光标前插入\n\n\n\n\nI\n在行首插入\n\n\n\n\na\n在光标后插入\n\n\n\n\nA\n在行末插入\n\n\n\n\no\n在当前行之下新建行\n\n\n\n\nO\n在当前行之上新建行\n\n\n\n\nr\n替换当前字符\n\n\n\n\nR\n从当前字符开始替换\n\n\n普通模式\n命令模式\n:\n\n\n\n普通模式\n可视模式\nv\n可视模式\n\n\n\n\nV\n可视行模式\n\n\n\n\nCtrl+v\n可视块模式\n\n\n移动在普通模式中，您可以使用以下方式移动光标\n    k(上)\n\n  h(左)    l(右)\n      j(下) \n\n您可以使用其它更有效率的方式移动光标\n\n\n\n\n向前\n向后\n\n\n\n单词\nw\nb\n\n\n单词，包括特殊符号\nW\nB\n\n\n单词词尾\ne\n\n\n\n单词词尾，包括特殊符号\nE\n\n\n\n\n\n\n\n\n行\n0\n$\n\n\n行首文字（不包括空格）\n^\n\n\n\n\n\n\n\n\n页\nH\nL\n\n\n页面中部\nM\n\n\n\n在其它模式中，您可以使用方向键移动光标，不过那样比较麻烦，您可以在配置文件中绑定插入模式下的功能键\nnoremap! &lt;M-j&gt; &lt;Down&gt;noremap! &lt;M-k&gt; &lt;Up&gt;noremap! &lt;M-h&gt; &lt;left&gt;noremap! &lt;M-l&gt; &lt;Right&gt;………………作用范围 键位 功能  \n\n其中，**map!绑定的键盘映射，作用于所有模式；inoremap!**绑定的映射，仅作用于插入模式。\n数字参数您也可以使用数字参数(普通模式)，来重复执行。例如\n#执行 100次j键，向下 100行100j\n\n浏览gg 定位到文件首行， V 进入可视行模式， G 定位到文件末行，实现类似“全选”的功能。依次按下 g g V(Shift+v) G(Shift+g)\n\n\n\n\n向前\n向后\n\n\n\n整页\nCtrl+f\nCtrl+b\n\n\n半页\nCtrl+d\nCtrl+u\n\n\n文件\nG\ngg\n\n\n按行号转到相应行\n行号 G\n\n\n\n按百分比转到相应的行\n1~100%\n\n\n\n按行卷动\nCtrl+e\nCtrl+y\n\n\n将光标所在行调整至页面中间\nzz\n\n\n\n统计字数\ng Ctrl+g\n\n\n\n显示位置信息\nCtrl+g\n\n\n\n刷新屏幕\nCtrl+l\n\n\n\n标记您可以在当前光标处作一个标记，以便快速返回\nm标记名称    定义标记。标记名称为一个字符`标记名称    返回标记mx           将当前光标处定义为标记 x`x           返回标记 x:marks       查看标记列表  \n\n编辑\n\n\n\n复制\n剪切\n\n\n\n字符\ny\nx\n\n\n行\nyy\ndd\n\n\n\n\n\n\n\n\n\n\np\n在光标后粘贴\n\n\nP\n在光标前粘贴\n\n\nu\n撤消\n\n\nCtrl+r\n重做\n\n\nCtrl+y\n逐字克隆上一行内容\n\n\nCtrl+e\n逐字克隆下一行内容\n\n\n搜索和替换按下 / 键，编辑器底部会出现 / 符号，接着输入字符串，便可以进行搜索\n\n\n\n\n\n\n\n\n\n\n&#x2F;\n向下搜索\n?\n向上搜索\n\n\nn\n搜索下一个\nN\n搜索上一个\n\n\n\n\n\n\n\n\n\n\n:s&#x2F;源字符串&#x2F;目标字符串\n将源字符串替换为目标字符串\n\n\n:s&#x2F;源字符串&#x2F;目标字符串&#x2F;g\n替换当前行中所有符合条件的字符串\n\n\n:行号1,行号2s&#x2F;源字符串&#x2F;目标字符串&#x2F;g\n在指定行中进行替换\n\n\n:%s&#x2F;源字符串&#x2F;目标字符串&#x2F;g\n全文替换\n\n\n寄存器操作Vim 可以将不同字段剪切或复制到不同寄存器中，您可以从不同寄存器中取出内容后粘贴\n&quot;寄存器名称\n\n按下**&quot;**键和另一个字符键，便可以定义一个寄存器。例如：&quot;a &quot;1\n定义寄存器后直接进行操作\n&quot;ayy    将当前行复制到寄存器 a 中&quot;ap     将寄存器 a 中的内容粘贴到光标之后\n\n\n:registers 查看所有寄存器的内容\n通常情况下，寄存器 + (先按”，再按 Shift+&#x3D; )对应 X 下的剪贴板。您在其它程序中复制的内容，可以使用 &quot;+p 粘贴到 Vim中；您在 Vim 中，可以使用 &quot;+y 将内容复制到剪贴板，再粘贴到其它程序中\n没有指定寄存器时，Vim 使用“无名寄存器”存储内容\n\n宏您可以将一系列的操作录制为一个宏，然后执行它\nq宏名称    开始录制宏。宏名称为一个字符q         录制中按下“q”键，结束录制@宏名称    执行宏\n\n\n可以使用 :registers（寄存器列表） 命令查看已记录的宏\n\n插入模式下的快捷键\n\n\n快捷键\n作用\n\n\n\nCtrl+r寄存器名称\n插入指定寄存器内容\n\n\nCtrl+k(2个字符)\n输入二合字符\n\n\nCtrl+v数字\n通过数字编码输入字符\n\n\nCtrl+v键位\n输入键位的名称\n\n\n键绑定、缩写前面我们已经向您介绍了键绑定\nmap! &lt;M-j&gt; &lt;Down&gt;\n\n尖括号及其中的内容，为 Vim 配置文件的约定，分别描述了按键和功能，表示将功能编写到按键上。如果绑定的只是普通字符，例如：\nmap! xxx XXXXX\n\n表示将 XXXXX 绑定到 xxx 上。当您键入 xxx 时，编辑器会自动替换为 XXXXX\n如果您只是想将字符串绑定为缩写，方便输入，我们建议您使用 iabbrev 来绑定。例如：\niabbrev g google\n\n在插入模式下键入 g ，编辑器会自动替换为 google 。您可以将 iabbrev 命令缩写为 iab ，例如：\niab g google\n\n以上命令，您可以直接在命令模式下输入，临时启用。也可以写入配置文件，永久启用。\n单词补全&lt;Ctrl+n&gt; 下一个匹配项&lt;Ctrl+p&gt; 上一个匹配项\n\n您可以在配置文件中定义补全的方式\n&quot;自动补全方式：(使用逗号分隔)set complete=k,.&quot;   .    当前文件&quot;   b    已被装缓冲区,但是没有在窗口内的文件&quot;   d    在当前的文件中定义和由 #include 包含进来的文件&quot;   i    由 #include 包含进来的文件&quot;   k    由 dictionary 选项定义的文件&quot;   kfile    名为&#123;file&#125;的文件&quot;   t    标记(tags)文件&quot;   u    没有载入的缓冲区&quot;   w    在其他窗口中的文件&quot;设定自动补全字典 ：set dictionary=path\n\n命令模式前面介绍了普通模式和插入模式。我们发现，普通模式主要用来浏览和修改文本内容，而插入模式则用来向文本中添加内容。\n而命令模式则多用于操作文本文件（而不是操作文本文件的内容），例如保存文件；或者用来更改编辑器本身的状态，例如设定多栏窗口、标签或者退出编辑器……\nw(rote) 将更改写入文件\n:w\n\nq(uit) 退出编辑器\n:q\n\n某些情况下，编辑器会阻止命令的执行。例如您修改了文件，而没有保存，那么您使用 :q 命令退出时，编辑器就不会执行这条命令，而是提醒您保存文件。\n这个时候，您可以在命令末尾追加 ! 来强制执行命令\n:命令!\n\n例如 :q! ，即便您没有保存已修改的文件，使用此命令，编辑器也会放弃修改而强行退出\n以 ! 引导一个 Shell 命令，则可以从 Vim 临时切换到 Shell 中，执行一个 Shell\n:!命令\n\n例如 :!ls\n命令模式还可以用来调节一些选项，例如\n:set linespace=6\n\n\n使用 Tab 键补全命令\n命令可以直接写入配置文件\n在选项后加上一个 &amp; 使用默认值，例如： :set linespace&amp;\n\n折叠\n\n\n命令\n作用\n\n\n\nzf数字\n创建折叠，数字参数为折叠行数\n\n\nzo\n打开折叠\n\n\nzc\n关闭折叠\n\n\nzd\n删除折叠\n\n\n:set foldcolumn&#x3D;4\n显示折叠树\n\n\n:mkview\n保存折叠\n\n\n:loadview\n读取折叠\n\n\nzr\n打开同一层级所有折叠\n\n\nzm\n关闭同一层级所有折叠\n\n\nzO\n打开某一行的所有层级折叠\n\n\nzC\n关闭某一行的所有层级折叠\n\n\nzR\n打开所有折叠\n\n\nzM\n关闭所有折叠\n\n\n:set foldclose&#x3D;all\n光标离开折叠自动关闭\n\n\n:set foldopen&#x3D;all\n光标遇到折叠自动打开\n\n\n您可以在配置文件中定义折叠的方式\n&quot;设定折叠方式set foldmethod=manual&quot; manual 手动折叠&quot; indent 按缩进折叠&quot; marker 按标记折叠&quot; syntax 按语法折叠&quot; expr   按表达式折叠\n\n按标记折叠的例子：\n#起始标记 &#123;&#123;&#123; 将标记放到注释里，不会影响文件的功能 起始标记和结束标记之间的内容折叠显示为起始标记所在行#结束标记 &#125;&#125;&#125;###### 将折叠方式写到模式行里 ###### vim: foldmethod=marker \n\n多栏窗口您可以使用以下命令，将当前窗口水平分为两栏\n:new\n\n新建一栏空白窗口，将当前文件分两栏显示\n:split\n\n同理，您可以使用下列命令，将当前窗口垂直分为两栏\n:vnew:vsplit\n\n先按下 ctrl+w 键，再按下方向键 j 、 k 、 l 、 h ，您可以切换到其它栏；在当前栏中使用 :q 命令，可以退出当前栏，也可以使用其它命令，对当前栏作出修改\n如果您希望当前命令在所有栏中生效，您可以在命令的末尾追加 all\n:命令all\n\n例如：**:qall**\n如果您希望这条命令强制执行，那么 ! 位于命令的最末，例如：**:qall!** 强行退出所有栏窗口\n标签页Vim 在7以后的版本，开始支持标签页的功能\n:tabnew    新建一个标签:tabnext   转到下一个标签:tabprevious  转到上一个标签\n\n您也可以使用鼠标点击标签进行切换\n文件管理使用 Vim 编辑目录时，会进入文件管理模式：\nvim .\n\n文件管理模式中可以实现一些简单的文件管理功能：\n\n\n\n命令\n作用\n\n\n\nenter\n打开文件或文件夹\n\n\nCtrl+o\n后退\n\n\no\n新开一栏进行编辑\n\n\nO\n在前一次打开的栏中编辑\n\n\np\n预览\n\n\ni\n显示&#x2F;隐藏文件大小、日期\n\n\ns\n切换文件排序方式\n\n\nr\n切换顺序、逆序\n\n\n-\n回到上一级目录\n\n\nc\n将 Vim 执行目录设定为当前目录\n\n\nR\n重命名\n\n\nD\n删除\n\n\nx\n运行\n\n\n\n:cd 设定所有窗口执行目录 ； :lcd 设定当前栏窗口执行目录\n\n加密使用 :X 命令为文件设定一个密码\n:XEnter encryption key: ******Enter same key again: ******\n\n\n如果要取消加密，可以设置密码为空\n\n可以禁用交换文件，以免泄密\nvim -x -n file.txt\n\n如果你已在经编辑这个文件了，那么交换文件 swapfile 可以用下面的命令禁止:\n:setlocal noswapfile\n\n由于没了交换文件，文件复原就不可能了。为了避免失去编辑的成果，要比平时更勤快地存盘你的文件\n现在你可以像平时一样编辑这个文件并把你所有的秘密放进去。当你编完文件要退出 Vim 时，这个文件就被加密存盘了\n当你下次用 Vim 编辑这个文件时，它就会询问你密码\n如果你试图用另一个程序来阅读这个文件，你将读到一堆垃圾。如果你用 Vim 来编辑这个文件，但输入了错误的密码，你也只能得到垃圾。Vim 并不具备检验密码正确性的机制 (这一点使得破译密码更为困难)\n","tags":["linux","vim"]}]